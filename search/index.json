[{"content":"凸多边形最优三角剖分 凸n边形的三角剖分与n-1个叶子的语法树之间存在一一对应关系。由于n个矩阵的完全加括号乘积与n个叶子的语法树之间存在一一对应关系，因此n个矩阵的完全加括号乘积也与凸(n+1)边形的三角剖分之间存在一一对应关系。 事实上，矩阵连乘积的最优计算次序问题是凸多边形最优三角剖分问题的一个特殊情形。 对于给定的矩阵链A1A2..An，定义一个与之相应的凸(n+1)边形P={v0 ,v1 ,… ,vn}，使得矩阵Ai与凸多边形的边vi-1vi一一对应。若矩阵Ai的维数为pi-1×pi,i=1,2,…,n，则定义三角形vivjvk上的权函数值为： ω(vivjvk)=pipjpk。依此权函数的定义，凸多边形P的最优三角剖分所对应的语法树给出矩阵链A1A2..An的最优完全加括号方式。\n最优子结构性质 递归结构 ","date":"2025-11-05T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/","title":"凸多边形最优三角剖分"},{"content":"编译原理期中复习-概念总结 ","date":"2025-11-04T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0-%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/","title":"期中复习-概念总结"},{"content":"信号量有关的同步问题 有限缓冲 1、分析需要的信号量个数\n1 2 3 Binary semaphore mutex = 1；//互斥信号量，实现对缓冲区的互斥访问 semaphore empty = n；//同步信号量，表示空闲缓冲区的数量 semaphore full = 0；//同步信号量，表示产品的数量，也即非空缓冲区的数量 2、类c代码 互斥信号量一定要放在同步信号量之后\n复杂读者-写者 普通 1 2 3 4 int r_cnt = 0; Semaphore wrt = 1; r_mutex = 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 writer(){ wait(wrt); //w signal(wrt); } reader(){ wait(r_mutex); r_cnt++; if(r_cnt == 1) wait(wrt); signal(r_mutex); //r wait(r_mutex); r_cnt--; if(r_cnt == 0) signal(wrt); signal(r_mutex); } 带队列的读-写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Semaphore q = 1; writer(){ wait(q); //逻辑不变 signal(q); } reader(){ wait(q); wait(r_mutex); r_cnt++; if(r_cnt == 1) wait(wrt); signal(r_mutex); signal(q); // 完成读计数之后就signal队列，之后你慢慢读没人管你 //r wait(r_mutex); r_cnt--; if(r_cnt == 0) signal(wrt); signal(r_mutex); } 扩展的读写者问题——最多允许M个读者同时读 四出生之家 可扩展到更多水果，核心是处理第一个和最后一个，保证盘内品种唯一\n哲学家吃屎 管程写法模板\n1 2 3 4 5 6 Monitor M{ enum {THINKING, EATING, HUNGRY} states[5]; condition self[5]; // void ... // void initialize(); } （期中）计数范围 三状态最大、最小值： 可以都在waiting，但是最多时必须有cpus个进程在running，所以ready_max = total - cpus\n","date":"2025-11-04T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","title":"第六章 进程同步"},{"content":"Chapter 6 The Entity-Relationship Model Entity Sets（实体集，实体型） 一张学生表是一个实体集，一个学生是一个实体（一行记录）\nRelationship Sets(关系集) 选课表就是一个关系集。它定义了“学生”和“课程”之间的“选修”这种关系。关系表示特定实体之间的一次具体关联。它对应的是联系表中的一行记录。 关系集也可以拥有自己的属性（关系集属性），用于描述关系的特征。它同样对应联系表中的列。选课表这个关系集可以有成绩、选修日期等属性，这些属性不属于学生，也不属于课程，而是属于“选修”这个行为本身。\nChoice of Primary key for Binary Relationship 在多的那一端把一的主键拿过来当外键\n多元联系(non-binary) 先转成多个二元联系再转表：将其他实体集的主键和关系自身属性建成表，各实体集不存放多余属性。\nE-R图（概念设计结果） Representing Cardinality Constraints in ER Diagram →：一 —：多 (one,many) x (one,many) = 4 种\n参与约束(Participant Constraints) 完全参与、部分参与\n逻辑设计阶段 E-R图转关系模式 实体、联系、属性（单值属性、多值属性、复合属性）如何转表？ 多值属性单独转表 复合属性拆开（如时间、地址）\n弱实体集、强实体集； 用实体还是属性？ Not to use the primary-key of an entity set as an attributes of another entity set (to represent implicitly association between these two entity sets), it is better to use an relationship set to explicitly show this association e.g. for the entity student, do not use instructor.id as its attribute, in stead of, representing association among student and instructor using relationship advisor.\n用实体还是关系？“动作”对应“联系”\n扩展ER （详情看ISA那篇） 面向对象ER：Object-oriented (OO) E-R specialization （特化，特殊化，例化） 自上而下，底层实体集是高层实体集的真子集 高层：超类；底层：子类\ngeneralization (概括化，泛化，普遍化) 自底向上\nattributes inheritance （属性继承） 联系也可以继承\nAggregation relationship on relationship（联系的联系）\nER图记号总结 ","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/","title":"Chapter6 ER模型"},{"content":"无损连接 有损连接：拆分再恢复时出现多余错误记录 数据依赖 在逻辑DBS设计过程中，将E-R图转换，得到面向特定应用领域的初始关系模式集。这些初始关系模式集中可能存在多种（作为完整性约束的）关系模式属性间的数据依赖 (Data Dependencies) 关系 函数依赖 (Functional Dependencies, FD, §7.2) 多值依赖 (Mutivalued Dependencies, MVD, §7.4, 7.6) 连接依赖 (Join Dependencies, JD) （略） 函数依赖是特殊的多值依赖 ","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%96/","title":"Chapter7 关系规范化"},{"content":"函数依赖（Functional Dependencies，简称FD） 是关系数据库理论中的一个核心概念，它描述了关系中属性之间的依赖关系。\n一、 基本定义 正式定义 在关系R中，如果属性集X的取值唯一确定属性集Y的取值，则称 X函数决定Y，或 Y函数依赖于X，记作：\n1 X → Y 通俗理解 \u0026ldquo;知道了X的值，就能唯一确定Y的值\u0026rdquo;\n二、 具体例子 例1：学生表 1 学生表(学号, 姓名, 院系, 院系地址) 函数依赖：\n1 2 3 4 学号 → 姓名 -- 知道学号，就能确定姓名 学号 → 院系 -- 知道学号，就能确定院系 学号 → 院系地址 -- 知道学号，就能确定院系地址 院系 → 院系地址 -- 知道院系，就能确定院系地址 例2：订单明细表 1 订单明细(订单号, 产品号, 数量, 产品名称, 单价) 函数依赖：\n1 2 3 (订单号, 产品号) → 数量 -- 主键决定数量 产品号 → 产品名称 -- 产品号决定产品名称 产品号 → 单价 -- 产品号决定单价 三、 函数依赖的类型 1. 完全函数依赖 Y完全依赖于X，且X的任何真子集都不能决定Y。\n1 2 3 4 -- 例子：选课表(学号, 课程号, 成绩) (学号, 课程号) → 成绩 -- 成绩完全依赖于(学号,课程号) 学号 ↛ 成绩 -- 学号单独不能决定成绩 课程号 ↛ 成绩 -- 课程号单独不能决定成绩 2. 部分函数依赖 Y依赖于X，但Y也依赖于X的某个真子集。\n1 2 3 -- 反例：选课表(学号, 课程号, 学生姓名, 成绩) (学号, 课程号) → 学生姓名 -- 但 学号 → 学生姓名 已经成立 -- 学生姓名部分依赖于(学号,课程号) 3. 传递函数依赖 通过中间属性间接依赖。\n1 2 3 4 -- 例子：学生表(学号, 院系, 院系地址) 学号 → 院系 -- 直接依赖 院系 → 院系地址 -- 直接依赖 学号 → 院系地址 -- 传递依赖（通过院系） 四、 函数依赖与键的关系 超键 能唯一标识元组的属性集。\n1 2 3 -- 学生表(学号, 姓名, 院系) {学号} 是超键 {学号, 姓名} 也是超键（但包含冗余） 候选键 最小超键（不含多余属性）。\n1 2 -- {学号} 是候选键 -- {学号, 姓名} 不是候选键（因为学号单独就是超键） 主键 从候选键中选择的一个。\n函数依赖视角 候选键是能函数决定所有其他属性的最小属性集。\n五、 函数依赖的推理规则（Armstrong公理） 1. 自反律 如果 Y ⊆ X，则 X → Y\n1 (学号, 姓名) → 学号 2. 增广律 如果 X → Y，则 XZ → YZ\n1 学号 → 姓名，则 (学号, 院系) → (姓名, 院系) 3. 传递律 如果 X → Y 且 Y → Z，则 X → Z\n1 学号 → 院系，院系 → 院系地址，则 学号 → 院系地址 推导规则 合并律：如果 X → Y 且 X → Z，则 X → YZ 分解律：如果 X → YZ，则 X → Y 且 X → Z 伪传递律：如果 X → Y 且 WY → Z，则 WX → Z 六、 函数依赖的应用 1. 数据库规范化 1 2 3 4 5 6 7 8 9 10 11 12 -- 未规范化的表：存在部分依赖 学生选课(学号, 姓名, 课程号, 课程名, 成绩) -- 函数依赖分析： 学号 → 姓名 -- 违反2NF 课程号 → 课程名 -- 违反2NF (学号, 课程号) → 成绩 -- 完全依赖 -- 规范化后： 学生表(学号, 姓名) 课程表(课程号, 课程名) 选课表(学号, 课程号, 成绩) 2. 找出所有的函数依赖 给定关系 R(A,B,C,D) 和 FD：{A→B, B→C}\n推导所有FD：\n1 2 3 4 5 6 A → B (已知) B → C (已知) A → C (传递律：A→B, B→C) A → BC (合并律：A→B, A→C) AB → B (增广律) ...等等 七、 闭包计算 属性闭包 X⁺ 在函数依赖集F下，能被X函数决定的所有属性的集合。\n算法：\n结果 = X 重复查找能由当前结果决定的属性，加入结果 直到结果不再变化 例子 已知 F = {A→B, B→C, C→D} 求 A⁺：\n1 2 3 4 A⁺ = {A} A⁺ = {A,B} (因为 A→B) A⁺ = {A,B,C} (因为 B→C) A⁺ = {A,B,C,D} (因为 C→D) 八、 实际数据库设计中的应用 识别不良设计 1 2 3 4 5 6 7 8 9 10 -- 不良设计：存在传递依赖 员工表(员工号, 姓名, 部门编号, 部门名称, 部门经理) -- 函数依赖： 员工号 → 姓名, 部门编号, 部门名称, 部门经理 部门编号 → 部门名称, 部门经理 -- 传递依赖！ -- 好的设计： 员工表(员工号, 姓名, 部门编号) 部门表(部门编号, 部门名称, 部门经理) 验证设计合理性 通过函数依赖分析，确保设计符合：\n2NF：消除非主属性对主键的部分依赖 3NF：消除非主属性对主键的传递依赖 BCNF：消除主属性对主键的部分和传递依赖 总结 函数依赖是数据库理论的基石：\n概念 意义 应用 X → Y X决定Y 描述数据关系 完全依赖 最小决定集 2NF规范化 部分依赖 冗余依赖 需要消除 传递依赖 间接依赖 3NF规范化 理解函数依赖能帮助你：\n✅ 设计出结构良好的数据库 ✅ 避免数据冗余和更新异常 ✅ 进行有效的数据库规范化 ✅ 保证数据的一致性 SQL statements for FD judgement 注意，左侧方框内的嵌套查询不可用，必须使用子查询：\n1 2 3 4 5 6 7 SELECT MAX(price_count) FROM ( SELECT COUNT(DISTINCT price) as price_count FROM part WHERE pname IS NOT NULL GROUP BY pname ) AS counts; ","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter7-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/","title":"Chapter7 函数依赖"},{"content":"","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E8%80%83%E8%AF%95%E9%87%8D%E7%82%B9/","title":"Chapter7 分解算法（考试重点）"},{"content":"关系规范化/Schema Normalization是一种数据库设计技术，旨在通过消除数据冗余和更新异常来组织关系数据库中的属性（列）和关系（表）。\n一、 规范化的核心目标 1. 消除数据冗余 1 2 3 4 5 6 7 8 -- 非规范化设计（冗余） 学生表(学号, 姓名, 课程号, 课程名, 教师, 教师办公室) -- 规范化设计（无冗余） 学生表(学号, 姓名) 课程表(课程号, 课程名, 教师编号) 教师表(教师编号, 教师姓名, 办公室) 选课表(学号, 课程号, 成绩) 2. 避免更新异常 插入异常：无法插入某些信息 删除异常：删除信息时丢失其他重要数据 修改异常：修改数据时出现不一致 二、 规范化范式（Normal Forms） 关系规范化分为多个层级，称为\u0026quot;范式\u0026quot;： 1. 第一范式（1NF） 要求：每个列都是原子的（不可再分）\n1 2 3 4 5 6 7 8 -- 违反1NF的例子 学生表(学号, 姓名, 选修课程) -- 数据：(\u0026#39;001\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;数学,英语,物理\u0026#39;) -- 符合1NF的设计 学生表(学号, 姓名) 选课表(学号, 课程名) -- 数据：多条记录分别存储每门课程 2. 第二范式（2NF） 要求：满足1NF，且非主属性完全依赖于主键\n1 2 3 4 5 6 7 8 -- 违反2NF的例子 选课表(学号, 课程号, 课程名, 成绩, 学分) -- 主键：(学号, 课程号) -- 问题：课程名、学分只依赖于课程号，不完全依赖于主键 -- 符合2NF的设计 选课表(学号, 课程号, 成绩) 课程表(课程号, 课程名, 学分) 3. 第三范式（3NF） 要求：满足2NF，且消除传递依赖\n1 2 3 4 5 6 7 -- 违反3NF的例子 学生表(学号, 姓名, 院系编号, 院系名称, 院系地址) -- 问题：院系名称、院系地址依赖于院系编号，院系编号依赖于学号 -- 符合3NF的设计 学生表(学号, 姓名, 院系编号) 院系表(院系编号, 院系名称, 院系地址) 三、 实际案例演示 非规范化设计（问题很多） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 销售记录表( 订单号, 客户编号, 客户姓名, 客户电话, 产品编号, 产品名称, 产品类别, 单价, 数量, 总金额, 销售员编号, 销售员姓名, 销售员部门 ) 存在的问题：\n数据冗余：客户信息、产品信息重复存储 更新异常：修改产品名称时需更新所有相关记录 插入异常：无法添加新客户如果没有订单 删除异常：删除订单会丢失客户信息 规范化后的设计 1 2 3 4 5 6 7 -- 第三范式设计 客户表(客户编号, 客户姓名, 客户电话) 产品表(产品编号, 产品名称, 产品类别, 单价) 销售员表(销售员编号, 销售员姓名, 部门编号) 部门表(部门编号, 部门名称) 订单表(订单号, 客户编号, 销售员编号, 订单日期) 订单明细表(订单号, 产品编号, 数量, 总金额) 四、 更高阶的范式 4. Boyce-Codd范式（BCNF） 比3NF更严格，消除所有函数依赖中的决定因素不是候选键的情况。\n5. 第四范式（4NF） 消除多值依赖。\n6. 第五范式（5NF） 消除连接依赖。\n五、 规范化的优缺点 优点 1 2 3 4 5 ✅ 减少数据冗余 ✅ 避免更新异常 ✅ 提高数据一致性 ✅ 简化数据结构 ✅ 便于维护和扩展 缺点 1 2 3 ❌ 查询可能变复杂（需要更多JOIN） ❌ 可能影响性能 ❌ 设计过程复杂 六、 实际应用建议 平衡原则 1 2 3 4 5 6 7 8 9 10 11 -- 有时需要反规范化以提高性能 -- 例如：在数据仓库中保留一些冗余数据 -- 规范化设计（3NF） 订单表(订单号, 客户编号) 客户表(客户编号, 客户姓名) 订单明细表(订单号, 产品编号, 数量) 产品表(产品编号, 产品名称, 单价) -- 反规范化设计（为了报表性能） 订单汇总表(订单号, 客户姓名, 产品名称, 数量, 单价, 总金额) 实际设计流程 需求分析 → 收集所有数据项 1NF设计 → 确保原子性 2NF设计 → 消除部分依赖 3NF设计 → 消除传递依赖 性能优化 → 根据需要适当反规范化 总结 关系规范化是数据库设计的理论基础：\n1NF：列不可再分 2NF：消除部分依赖 3NF：消除传递依赖 目标：结构清晰、数据一致、维护方便 在实际项目中，通常设计到第三范式（3NF），然后根据性能需求进行适当的反规范化调整。\n","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/deepseek%E6%80%BB%E7%BB%93%E7%9A%84%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%96/","title":"Deepseek总结的关系规范化"},{"content":"ISA关系（6.8） ISA Relationship 指的是一种特定的数据建模技术，用于在概念模型（如ER图）中表示实体之间的继承关系。\nISA 是 “IS-A” 的缩写，例如 “A Manager IS-AN Employee”（一个经理 是 一个员工）。它描述了一种父类型（超类型） 和子类型 之间的层次关系。\n核心概念 在数据库设计中，ISA关系用于捕捉现实世界中存在的分类结构。\n超类型 / 父类： 一个更一般化、更抽象的实体。 例如：人(Person)、账户(Account)、车辆(Vehicle) 子类型 / 子类： 一个更具体、更特化的实体，它是超类型的一种。 例如：员工(Employee) 和 学生(Student) 是 人(Person) 的子类型。 储蓄账户(SavingsAccount) 和 支票账户(CheckingAccount) 是 账户(Account) 的子类型。 ISA关系的两个关键约束 当你在设计中使用ISA关系时，必须定义两个重要的约束：\n1. 重叠约束（Disjoint/Overlapping Constraint） 规定一个超类型的实例是否可以同时属于多个子类型。\n不允许重叠： 一个超类实例只能属于一个子类型。 例如：一个 账户(Account) 要么是 储蓄账户(SavingsAccount)，要么是 支票账户(CheckingAccount)，但不能同时是两者。用 “OR” 表示。 允许重叠： 一个超类实例可以同时属于多个子类型。 例如：一个 人(Person) 可以同时是 员工(Employee) 和 学生(Student)。用 “AND” 表示。 2. 完备性约束（Completeness constraint） 规定超类型中的每一个实例是否都必须至少属于一个子类型。\n全完备性（total）： 超类型的每一个实例都必须是某个子类型的实例。 例如：公司规定，每一个 员工(Employee) 都必须是 小时工(HourlyEmployee) 或 月薪工(SalariedEmployee) 中的一种。超类型 员工(Employee) 不会存在不属于任何子类的“孤例”。在ER图中，用双线表示。 部分完备性（partial）： 超类型的实例可以不属于任何子类型。 例如：一个 人(Person) 可以只是普通人，既不是 员工(Employee)，也不是 学生(Student)。在ER图中，用单线表示。 在数据库中的实现方式 ISA层次结构在物理数据库中主要有三种实现方式：\r1. 每个具体类一张表 方法： 忽略超类型，只为每个子类型创建一张表。这张表包含该子类型特有的属性，以及从超类型继承来的所有属性。 举例： 创建 学生表(Students) 和 员工表(Employees)，没有 人表(Persons)。Students表中有 student_id, name, age, major 等字段。 优点： 查询特定子类型的数据时速度快。 缺点： 数据冗余（如果一个人既是学生又是员工，他的name和age信息会在两张表中重复存储）。 难以对所有人进行统一查询（需要UNION操作）。 无法表示不属于任何子类的人。 2. 单张表 方法： 将整个层次结构“扁平化”为一张表。这张表包含超类型和所有子类型的所有属性。同时，增加一个“类型鉴别”字段来标识每一行属于哪个子类型。 举例： 创建一张 人表(Persons)，包含字段：person_id, name, age, person_type, major, salary, department。 如果 person_type = ‘Student’，那么 major 字段有意义，salary 字段为NULL。 如果 person_type = ‘Employee’，那么 salary 字段有意义，major 字段为NULL。 优点： 统一查询非常简单，不需要JOIN操作。 缺点： 表中存在大量NULL值，浪费存储空间。 表结构会随着子类型的增加而变得非常庞大和复杂。 3. 超类型和子类型分别建表 方法： 为超类型和每一个子类型都创建一张表。 超类型表包含所有实例共享的公共属性（和一个主键）。 子类型表只包含其特有的属性，并共享超类型表的主键（即子类型表的主键同时也是引用超类型表的外键）。 举例： 人表(Persons)：person_id (PK), name, age 学生表(Students)：person_id (PK, FK references Persons), major 员工表(Employees)：person_id (PK, FK references Persons), salary, department 优点： 设计规范，消除了数据冗余。 易于添加新的子类型。 能很好地支持重叠约束（一个人可以同时在Students和Employees表中有记录）。 缺点： 查询数据时需要频繁使用JOIN操作，性能可能成为瓶颈。 总结 在数据库领域中，ISA Relationship 是一个强大的概念建模工具，它清晰地表达了 “是一个” 的继承关系。理解并正确定义其重叠约束和完备性约束至关重要，因为它直接影响到最终数据库表结构的设计选择（每种实现方式都有其优缺点，需要根据具体应用场景进行权衡）。\n","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/deepseek%E6%95%B4%E7%90%86%E7%9A%84isa/","title":"Deepseek整理的ISA"},{"content":"\\o/ \\o/ \\o/\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/blog%E4%BA%8C%E5%91%A8%E7%9B%AE%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF/","title":"blog二周目正式上线"},{"content":"关系数据库结构 table、relation、attributes\nkey A superkey (超键) is a set of one or more attributes that, taken collectively, can be used to identify uniquely a tuple in the relation.\nK is a candidate key (候选键) if K is minimal super key. e.g.{ID} is a candidate key for instructor, assuming no two instructors can possibly have the same identifiers. A relation may have several candidate keys\nPrimary key (主键) is a candidate key chosen by the database designer as principal means to identify tuples within a relation\nDef. Primary attributes (主属性!) taking the key as a attribute set, the attributes in the candidate keys, i.e. the element of the primary key is called the primary attributes non-primary attributes (非主属性)\nSuper key \u0026gt;= candidate key \u0026gt;= primary key\nrelational algebra (关系代数) Six basic operators (选择) select: $\\sigma$ (投影) project: (笛卡尔积) Cartesian product: x (集合并) union: (集合差) set difference: – (重命名) rename: 复合关系运算 暂时值（Assignment） ","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","title":"Chapter2 关系数据库基础"},{"content":"SQL 语法 SELECT distinct 去重 1 2 select `distinct/all` dept_name from instructor 四则运算和重命名 1 select ID, name, salary/12 as monthly_salary FROM natural join 自然连接 1 2 3 4 select name, course_id from instructor natural join teaches where instructor. dept_name = ‘Art’ // 等价于加上 where instructor.ID = teaches.ID and WHERE SQL allows the use of the logical connectives and, or, and not The operands of the logical connectives can be expressions involving the comparison operators \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, =, and \u0026lt;\u0026gt;.（以及between A and B 用法）\nTuple comparison 1 2 3 select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, \u0026#39;Biology\u0026#39;); Tuple Variables 涉及到对instructor关系中属性salary的不同值的比较\n1 2 3 select distinct T.name from instructor as T, instructor as S where T.salary \u0026gt; S.salary and S.dept_name = ‘Comp. Sci.’ 执行顺序 FROM - 从表中获取数据\nWHERE - 对原始行数据进行筛选\nGROUP BY - 对筛选后的数据进行分组\nHAVING - 对分组后的聚合结果进行筛选\nSELECT - 选择要显示的列\n在 WHERE 子句中不能直接使用 COUNT 等聚合函数，因为执行顺序的问题。\n1 2 3 4 5 -- ✅ 正确：使用HAVING对分组结果进行筛选 SELECT department, COUNT(*) as emp_count FROM employees GROUP BY department HAVING COUNT(*) \u0026gt; 5; -- 这里COUNT()在每组内计算 CTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 WITH department_stats AS ( SELECT department, AVG(salary) as avg_salary, COUNT(*) as employee_count FROM employees GROUP BY department ), high_avg_departments AS ( -- 这个CTE引用了前一个CTE SELECT department, avg_salary FROM department_stats WHERE avg_salary \u0026gt; 6000 ) -- 主查询 SELECT e.name, e.salary, h.avg_salary as department_avg FROM employees e JOIN high_avg_departments h ON e.department = h.department WHERE e.salary \u0026gt; h.avg_salary; GROUP BY Attributes in select clause outside of aggregate functions must appear in group by list（必须要有聚合运算） 错误示例：\n1 2 3 4 /* erroneous query */ select dept_name, ID, avg (salary) -- ID 不在聚合属性中 from instructor group by dept_name 正确用法：（可以有多个聚合运算）\nproduct category sales_amount A Electronics 100 B Electronics 150 A Electronics 200 C Clothing 80 B Electronics 120 1 2 3 4 5 6 SELECT category, COUNT(*) as transaction_count, SUM(sales_amount) as total_sales FROM sales GROUP BY category; category transaction_count total_sales Electronics 4 570 Clothing 1 80 常用聚合函数\n1 2 3 4 5 6 7 8 9 SELECT department, COUNT(*) as employee_count, -- 计数 AVG(salary) as avg_salary, -- 平均值 SUM(salary) as total_salary, -- 求和 MAX(salary) as max_salary, -- 最大值 MIN(salary) as min_salary -- 最小值 FROM employees GROUP BY department; ORDER BY 1 2 SELECT * FROM employees ORDER BY salary DESC; SELECT * FROM employees ORDER BY department ASC, salary DESC; ","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter3-sql-ppt/","title":"Chapter3 SQL ppt"},{"content":"NOT EXISTS 和 EXCEPT 是 SQL 中用于处理集合差集的高级操作，它们在不同场景下非常有用。\n一、 NOT EXISTS 用法 1. 基本语法 1 2 3 4 5 6 7 SELECT columns FROM table1 t1 WHERE NOT EXISTS ( SELECT 1 FROM table2 t2 WHERE t1.related_column = t2.related_column ); 2. 实际例子 例1：找出没有项目的员工 1 2 3 4 5 6 7 SELECT e.employee_id, e.name FROM employees e WHERE NOT EXISTS ( SELECT 1 FROM projects p WHERE p.leader_id = e.employee_id ); 例2：找出没有订单的客户 1 2 3 4 5 6 7 SELECT c.customer_id, c.customer_name FROM customers c WHERE NOT EXISTS ( SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id ); 例3：找出从未被订购的产品 1 2 3 4 5 6 7 SELECT p.product_id, p.product_name FROM products p WHERE NOT EXISTS ( SELECT 1 FROM order_items oi WHERE oi.product_id = p.product_id ); 3. 复杂例子：找出没有下属的管理者 1 2 3 4 5 6 7 8 SELECT e1.employee_id, e1.name FROM employees e1 WHERE e1.is_manager = 1 AND NOT EXISTS ( SELECT 1 FROM employees e2 WHERE e2.manager_id = e1.employee_id ); 二、 EXCEPT 用法 1. 基本语法 1 2 3 SELECT column1, column2 FROM table1 EXCEPT SELECT column1, column2 FROM table2; 2. 实际例子 例1：找出只在A表不在B表的记录 1 2 3 4 -- 找出在employees表但不在former_employees表的员工 SELECT employee_id, name FROM employees EXCEPT SELECT employee_id, name FROM former_employees; 例2：找出有库存但从未被订购的产品 1 2 3 SELECT product_id FROM inventory EXCEPT SELECT product_id FROM order_items; 例3：多列比较 1 2 3 4 -- 找出在2023年有销售但2024年没有的客户 SELECT customer_id, product_id FROM sales_2023 EXCEPT SELECT customer_id, product_id FROM sales_2024; 三、 NOT EXISTS vs EXCEPT 对比 相同需求的不同实现 需求：找出没有项目的部门 使用 NOT EXISTS:\n1 2 3 4 5 6 7 SELECT d.department_id, d.department_name FROM departments d WHERE NOT EXISTS ( SELECT 1 FROM projects p WHERE p.department_id = d.department_id ); 使用 EXCEPT:\n1 2 3 4 5 6 SELECT department_id, department_name FROM departments EXCEPT SELECT d.department_id, d.department_name FROM departments d JOIN projects p ON d.department_id = p.department_id; 四、 高级应用场景 1. 多层 NOT EXISTS（复杂逻辑） 找出所有产品都库存充足的产品类别 1 2 3 4 5 6 7 8 9 SELECT c.category_id, c.category_name FROM categories c WHERE NOT EXISTS ( -- 找出该类别中库存不足的产品 SELECT 1 FROM products p WHERE p.category_id = c.category_id AND p.current_stock \u0026lt; p.minimum_stock ); 2. EXCEPT 用于数据验证 验证两个表的结构一致性 1 2 3 4 -- 找出在source_table中存在但在target_table中不存在的记录 SELECT id, name, value FROM source_table EXCEPT SELECT id, name, value FROM target_table; 3. 组合使用 NOT EXISTS 和 EXISTS 找出只订购过一次的客户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT c.customer_id, c.customer_name FROM customers c WHERE EXISTS ( -- 至少有一个订单 SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id ) AND NOT EXISTS ( -- 没有第二个订单 SELECT 1 FROM orders o1, orders o2 WHERE o1.customer_id = c.customer_id AND o2.customer_id = c.customer_id AND o1.order_id \u0026lt;\u0026gt; o2.order_id ); 五、 性能考虑和最佳实践 1. NOT EXISTS 通常性能更好 1 2 3 4 5 6 7 -- 推荐：使用NOT EXISTS SELECT * FROM table1 t1 WHERE NOT EXISTS (SELECT 1 FROM table2 t2 WHERE t2.id = t1.id); -- 不推荐：使用NOT IN（对NULL值处理有问题） SELECT * FROM table1 WHERE id NOT IN (SELECT id FROM table2 WHERE id IS NOT NULL); 2. EXCEPT 自动去重 1 2 3 4 -- EXCEPT 会自动去除重复记录 SELECT department FROM employees EXCEPT SELECT department FROM former_employees; 3. 处理NULL值 1 2 3 4 5 6 -- NOT EXISTS 能正确处理NULL值 SELECT * FROM products p WHERE NOT EXISTS ( SELECT 1 FROM discontinued_products dp WHERE dp.product_id = p.product_id ); 六、 实际业务场景 场景1：电商平台 - 找出从未被浏览的商品 1 2 3 4 5 6 7 SELECT product_id, product_name FROM products WHERE NOT EXISTS ( SELECT 1 FROM user_browsing_history WHERE product_id = products.product_id ); 场景2：学校系统 - 找出没有选课的学生 1 2 3 4 5 6 SELECT student_id, student_name FROM students EXCEPT SELECT s.student_id, s.student_name FROM students s JOIN enrollments e ON s.student_id = e.student_id; 场景3：银行系统 - 找出有账户但从未交易的客户 1 2 3 4 5 6 7 8 SELECT c.customer_id, c.customer_name FROM customers c JOIN accounts a ON c.customer_id = a.customer_id WHERE NOT EXISTS ( SELECT 1 FROM transactions t WHERE t.account_id = a.account_id ); 总结 NOT EXISTS: 更适合关联查询，性能通常较好，能正确处理NULL值 EXCEPT: 更适合比较两个结果集的差异，语法更直观，自动去重 选择依据: 需要关联条件时用 NOT EXISTS 直接比较两个查询结果时用 EXCEPT 考虑数据库优化器和具体数据量进行测试 两者都是处理\u0026quot;在A中但不在B中\u0026quot;这类需求的强大工具！\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter3-sql%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/","title":"Chapter3 SQL集合操作"},{"content":" 一、 基础查询 (Basic Queries) 1. SELECT \u0026amp; FROM 1 2 SELECT * FROM employees; SELECT name, salary FROM employees; 2. WHERE 条件筛选 1 2 3 4 5 SELECT * FROM employees WHERE salary \u0026gt; 5000; SELECT * FROM employees WHERE department = \u0026#39;IT\u0026#39; AND salary \u0026gt; 6000; SELECT * FROM employees WHERE name LIKE \u0026#39;A%\u0026#39;; -- 名字以A开头 SELECT * FROM employees WHERE age BETWEEN 25 AND 35; SELECT * FROM employees WHERE department IN (\u0026#39;IT\u0026#39;, \u0026#39;HR\u0026#39;, \u0026#39;Finance\u0026#39;); 3. ORDER BY 排序 1 2 SELECT * FROM employees ORDER BY salary DESC; SELECT * FROM employees ORDER BY department ASC, salary DESC; 4. DISTINCT 去重 1 SELECT DISTINCT department FROM employees; 二、 聚合函数与分组 (Aggregation \u0026amp; Grouping) 5. 聚合函数 1 2 3 4 5 6 7 SELECT COUNT(*) as total_employees, AVG(salary) as avg_salary, MAX(salary) as max_salary, MIN(salary) as min_salary, SUM(salary) as total_salary FROM employees; 6. GROUP BY 分组 1 2 3 4 5 6 SELECT department, COUNT(*) as emp_count, AVG(salary) as avg_salary FROM employees GROUP BY department; 7. HAVING 分组后筛选 1 2 3 4 5 6 SELECT department, COUNT(*) as emp_count FROM employees GROUP BY department HAVING COUNT(*) \u0026gt; 5; 三、 多表连接 (Joins) 8. INNER JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e INNER JOIN departments d ON e.department_id = d.id; 9. LEFT/RIGHT JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e LEFT JOIN departments d ON e.department_id = d.id; 10. FULL OUTER JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e FULL OUTER JOIN departments d ON e.department_id = d.id; 11. 多表连接 1 2 3 4 SELECT e.name, d.department_name, p.project_name FROM employees e JOIN departments d ON e.department_id = d.id JOIN projects p ON e.id = p.leader_id; 四、 子查询 (Subqueries) 12. 标量子查询 1 2 3 SELECT name, salary, (SELECT AVG(salary) FROM employees) as company_avg FROM employees; 13. IN 子查询 1 2 3 4 5 SELECT name FROM employees WHERE department_id IN ( SELECT id FROM departments WHERE budget \u0026gt; 100000 ); 14. EXISTS 子查询 1 2 3 4 5 6 SELECT name FROM employees e WHERE EXISTS ( SELECT 1 FROM projects p WHERE p.leader_id = e.id ); 15. 关联子查询 1 2 3 4 5 6 7 SELECT name, salary, department FROM employees e1 WHERE salary \u0026gt; ( SELECT AVG(salary) FROM employees e2 WHERE e2.department = e1.department ); 五、 高级查询技术 (Advanced Techniques) 16. CTE (公用表表达式) 1 2 3 4 5 6 7 8 WITH department_stats AS ( SELECT department, AVG(salary) as avg_salary FROM employees GROUP BY department ) SELECT * FROM department_stats WHERE avg_salary \u0026gt; 6000; 17. 递归 CTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 WITH RECURSIVE org_chart AS ( -- 基础情况 SELECT employee_id, name, manager_id, 1 as level FROM employees WHERE manager_id IS NULL UNION ALL -- 递归情况 SELECT e.employee_id, e.name, e.manager_id, oc.level + 1 FROM employees e JOIN org_chart oc ON e.manager_id = oc.employee_id ) SELECT * FROM org_chart; 18. 窗口函数 1 2 3 4 5 6 7 8 SELECT name, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank, AVG(salary) OVER (PARTITION BY department) as dept_avg_salary, LAG(salary) OVER (ORDER BY salary) as prev_salary FROM employees; 19. PIVOT 行列转换 1 2 3 4 5 6 7 8 9 10 -- SQL Server SELECT * FROM ( SELECT department, salary FROM employees ) AS SourceTable PIVOT ( AVG(salary) FOR department IN ([IT], [HR], [Finance]) ) AS PivotTable; 六、 数据操作 (Data Manipulation) 20. INSERT 1 2 3 4 5 6 INSERT INTO employees (name, salary, department) VALUES (\u0026#39;John Doe\u0026#39;, 5000, \u0026#39;IT\u0026#39;); -- 插入查询结果 INSERT INTO high_paid_employees (name, salary) SELECT name, salary FROM employees WHERE salary \u0026gt; 8000; 21. UPDATE 1 2 3 4 5 6 7 8 9 10 UPDATE employees SET salary = salary * 1.1 WHERE department = \u0026#39;IT\u0026#39;; -- 使用子查询更新 UPDATE employees SET salary = ( SELECT AVG(salary) FROM employees ) WHERE salary IS NULL; 22. DELETE 1 2 3 4 5 6 7 DELETE FROM employees WHERE salary \u0026lt; 3000; -- 使用子查询删除 DELETE FROM employees WHERE department_id IN ( SELECT id FROM departments WHERE active = 0 ); 23. MERGE/UPSERT 1 2 3 4 5 -- PostgreSQL INSERT INTO employees (id, name, salary) VALUES (1, \u0026#39;John\u0026#39;, 5000) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, salary = EXCLUDED.salary; 七、 事务控制 (Transaction Control) 24. 事务处理 1 2 3 4 5 6 7 8 9 10 BEGIN TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 如果一切正常 COMMIT; -- 如果出现错误 ROLLBACK; 八、 性能优化相关 25. 索引使用 1 2 CREATE INDEX idx_employee_department ON employees(department); CREATE INDEX idx_employee_name_salary ON employees(name, salary); 26. 分页查询 1 2 3 4 5 -- MySQL SELECT * FROM employees ORDER BY id LIMIT 10 OFFSET 20; -- SQL Server SELECT * FROM employees ORDER BY id OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY; 27. 查询性能分析 1 2 3 4 5 6 -- 查看执行计划 EXPLAIN SELECT * FROM employees WHERE salary \u0026gt; 5000; -- SQL Server SET STATISTICS TIME ON; SELECT * FROM employees WHERE salary \u0026gt; 5000; 九、 实用函数 28. 字符串函数 1 2 3 4 5 6 7 SELECT UPPER(name) as upper_name, LOWER(name) as lower_name, LENGTH(name) as name_length, SUBSTRING(name, 1, 3) as name_prefix, CONCAT(first_name, \u0026#39; \u0026#39;, last_name) as full_name FROM employees; 29. 日期函数 1 2 3 4 5 6 SELECT CURRENT_DATE as today, EXTRACT(YEAR FROM hire_date) as hire_year, DATE_ADD(hire_date, INTERVAL 1 YEAR) as anniversary, DATEDIFF(CURRENT_DATE, hire_date) as days_employed FROM employees; 30. 条件表达式 1 2 3 4 5 6 7 8 9 10 SELECT name, salary, CASE WHEN salary \u0026lt; 3000 THEN \u0026#39;Low\u0026#39; WHEN salary BETWEEN 3000 AND 7000 THEN \u0026#39;Medium\u0026#39; ELSE \u0026#39;High\u0026#39; END as salary_level, COALESCE(bonus, 0) as bonus_amount FROM employees; 这份指南涵盖了 SQL 从基础到高级的大部分常用语法。建议在实际工作中根据需要查阅相关部分，并通过练习来熟练掌握。\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/deepseek%E6%95%B4%E7%90%86%E7%9A%84sql/","title":"Deepseek整理的SQL"},{"content":"思想 递归\n分治的条件 规模缩小到一定程度可以容易解决 具有最优子结构性质 子问题的解可以合并为该问题的解（与动态规划的区别）（不能：贪心、DP） 不包含公共子问题（各个子问题相互独立，否则使用DP） 快速排序：原地排序、$nlogn$ 2.3 二分搜索 2.4 大整数乘法 2.5 Strassen矩阵乘法 2.7 合并排序 2.8 快速排序 2.9 选择问题 长度为$n$线性有序集合，找出第$k$小 分治，$pivot$ 线性时间选择问题，问题规模 $0\u0026lt;\\epsilon\u0026lt;1$\n步骤 划分成$\\frac{n}{5}$个组 各组内任意排序 每组中，$pivot_{i}$ = 中位数 一共$\\frac{n}{5}$个$pivot$，再找出中位数 只有75个元素以上才能缩小$\\frac{1}{4}$ 补充 划分因子选择3、7：7可以，3不行\n2.10 最近点对问题 直线 暴力$O(n^{2})$ 一次排序、一维扫描，$O(nlogn)$\n二维 蛮力；分治（平衡子问题） 如何分治？能在线性时间内完成？\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E5%88%86%E6%B2%BB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"分治基本概念"},{"content":"分治 左侧从右向左，右侧从左向右\nDP 从前向后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void MAXSUB(int a[], int n){ int *b = new int[MAX]; int *rec = new int[max]; b[0] = a[0]; rec[0] = 0; int max = b[0]; for(int i = 1; i \u0026lt; n; i++){ if(b[i-1] \u0026gt; 0) { b[i] = b[i-1] + a[i]; rec = rec[i-1]; } else{ b[i] = a[i]; rec = i; } if(b[i] \u0026gt; max) max = b[i]; } } ","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/","title":"最大子段和"}]