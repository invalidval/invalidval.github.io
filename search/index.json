[{"content":"Functional-Dependency Theory SQL for judging FDs Closure of a Set of Functional Dependencies The set of all functional dependencies logically implied by F is the closure of F, which is denoted as F+. It is the set of all functional dependencies that can be inferred from F using Armstrong\u0026rsquo;s axioms. These axioms include:\nReflexivity: If Y ⊆ X, then X → Y holds. Augmentation: If X → Y holds, then XZ → YZ holds for any Z. Transitivity: If X → Y and Y → Z hold, then X → Z holds. Armstrong\u0026rsquo;s Axioms Armstrong\u0026rsquo;s axioms are a set of rules used to infer all the functional dependencies in a relational database. They are sound (i.e., they only produce valid dependencies) and complete (i.e., they can produce all valid dependencies).\nReflexivity: If Y is a subset of X, then X → Y holds. Augmentation: If X → Y holds, then XZ → YZ holds for any Z. Transitivity: If X → Y and Y → Z hold, then X → Z holds. Additional Rules Union: If X → Y and X → Z hold, then X → YZ holds. Decomposition: If X → YZ holds, then X → Y and X → Z hold. Pseudotransitivity: If X → Y and YZ → W hold, then XZ → W holds. （可由先argumentation和transitivity推导出） 属性集闭包 属性集X在函数依赖集F下的闭包，记为X+，是指在F中可以由X推导出的所有属性的集合。 计算X+的算法：\n初始化X+为X。 重复以下步骤，直到X+不再变化： 对于F中的每个函数依赖A → B，如果A是X+的子集，则将B添加到X+中。 例子 设有关系R(A, B, C, D)和函数依赖集F = {A → B, B → C}，计算属性集A的闭包A+：\n初始化A+ = {A}。 应用A → B，因为A是A+的子集，添加B到A+，得到A+ = {A, B}。 应用B → C，因为B是A+的子集，添加C到 A+，得到A+ = {A, B, C}。 没有更多的函数依赖可以应用，算法终止。 最终，A+ = {A, B, C}。 Canonical Cover【最简函数依赖集】 函数依赖集F的规范覆盖（Canonical Cover），记为Fc，是一个等价于F的最小函数依赖集。规范覆盖具有以下性质：\n每个函数依赖的右侧只有一个属性。 没有冗余的函数依赖。 没有冗余的属性在函数依赖的左侧。 计算规范覆盖的步骤 将每个函数依赖的右侧拆分为单个属性。 移除冗余的函数依赖。 移除冗余的属性在函数依赖的左侧。 例子 。\nExtraneous Attributes（冗余属性） 在函数依赖X → Y中，如果存在属性A ∈ X，使得在去掉A后，X - {A} → Y仍然成立，则称A是冗余属性。\n例子 设有函数依赖集F = {AB → C, A → B}，检查属性A在AB → C中是否冗余：\n计算B的闭包B+： 初始化B+ = {B}。 没有函数依赖可以应用，B+ = {B}。 检查是否B+包含C： B+不包含C，因此A不是冗余属性。 最终，属性A在AB → C中不是冗余属性。 对于右端冗余属性的检查： 在函数依赖X → Y中，如果存在属性B ∈ Y，使得在去掉B后，X → Y - {B}仍然成立，则称B是冗余属性。 移除左端冗余属性，得到更强的函数依赖【所需左端前提条件更少】 移除右端冗余属性，得到更弱的函数依赖【结论更少】\n一个依赖关系under F的意思是可以从F中推导出该依赖关系\nDependency Preservation（依赖保持） 在关系模式分解中，如果分解后的每个子模式的函数依赖集的联合能够推导出原始模式的所有函数依赖，则称该分解是依赖保持的。\n1 2 3 与holds on的区别在于， holds on是指某个具体的关系实例满足某个函数依赖， 而dependency preservation是指分解后的模式在所有可能的关系实例中都能保持原始模式的函数依赖。 7.5 Algorithms for Decomposition Using Functional Dependencies 本节内容 BCNF Testing for BCNF /判断关系模式是否是BCNF Testing Decomposition for BCNF/ 判断分解后的子模式是否是BCNF BCNF decomposition algorithm/将关系模式分解为BCNF的方法 3NF Testing for 3NF 3NF decomposition algorithm Comparison of BCNF and 3NF\nTesting for BCNF 判断关系模式R是否是BCNF的步骤：\n计算函数依赖集F的规范覆盖Fc。 对于Fc中的每个函数依赖X → Y，检查X是否是R的超键。 如果所有函数依赖的左侧都是超键，则R是BCNF；否则，R不是BCNF。 Testing Decomposition for BCNF Note:\nthe restriction of F to Ri 的意思是： 将函数依赖集F中的所有函数依赖限制在子模式Ri上，即只保留那些在Ri中有效的函数依赖。 举例子： 设有关系模式R(A, B, C)和函数依赖集F = {A → B, B → C}，将R分解为子模式R1(A, B)和R2(B, C)。 the restriction of F to R1是{A → B}，因为B → C在R1中无效。 测试由R分解后的子模式Ri是否BCNF，不能仅凭R上的F，应该采用F+\nDecomposition Algorithm for BCNF 检查关系模式R是否是BCNF。如果是，则返回R作为分解结果。 如果R不是BCNF，找到一个违反BCNF的函数依赖X → Y，其中X不是R的超键。 将R分解为两个子模式R1和R2： R1 = X ∪ Y R2 = R - Y + X 递归地对R1和R2应用步骤1-3，直到所有子模式都是BCNF。 Note: 3中R1的意思是包含X和Y的所有属性的子模式，R2的意思是R中去掉Y属性后再加上X属性的子模式 该算法可能不会产生依赖保持的分解。 该算法确保每个子模式都是BCNF。 BCNF分解不保证依赖保持 Decomposition Algorithm for 3NF 为什么需要3NF分解算法？ 因为BCNF分解不保证依赖保持，而3NF分解算法可以保证依赖保持。\ntesting for 3NF has been shown to be NP-hard, Interestingly, decomposition into third normal form (described shortly) can be done in polynomial time 算法步骤：\n计算函数依赖集F的规范覆盖Fc。 对于Fc中的每个函数依赖X → Y，创建一个子模式R_i = X ∪ Y。 如果没有子模式包含R的候选键，则添加一个子模式R_k，该子模式包含R的一个候选键。 返回所有子模式作为分解结果。 Example of 3NF Decomposition 设有关系模式R(A, B, C, D)和函数依赖集F = {A → B, B → C}，应用3NF分解算法：\n计算规范覆盖Fc = {A → B, B → C}。 创建子模式： R1 = {A, B}（对应A → B） R2 = {B, C}（对应B → C） （R1、R2都是BCNF） R的候选键是{A, D}，没有子模式包含它，因此添加R3 = {A, D}。 返回子模式R1, R2, R3作为分解结果。 Note:\n只要有一个候选键包含在第2步构造出的某个子模式Ri中，就无需在第3步中，为候选键单独构造子模式。 任意挑选R的一个候选键【只需挑选一个】，对该候选健单独构造一个关系模式；无需考虑全部候选键!!! Appendix 7-1 Computing Candidate Keys 计算候选键的步骤：\nstep1. 将R的所有属性分为四类：\nL类：仅出现在F中函数依赖左部的属性 R类：仅出现在F中函数依赖右部的属性 N类：在F中函数依赖左右两边均未出现的属性 LR类：在F中函数依赖左右两边均出现的属性 令X_set=L类 ∪ N类，Y_set=LR类 step2. 求X_set +，\n如果X_set+ =R，则X_set为R的唯一候选键，转step5；否则转step3 step3.\n在Y_set中取一属性A，求(X_set ∪ A)+，若它包含了R的所有属性，则转step4; 否则，调换一属性反复进行这一过程，直到试完所有Y_set中的属性 step4.\n如果已找出所有的候选键，则转step5; 否则，在Y_set中依此取两个、三个，…，求其属性闭包，直至其闭包包含R的所有的属性 step5. 停止，输出结果 最后，为什么需要4NF 在某些情况下，关系模式可能存在多值依赖（MVD），这会导致数据冗余和更新异常。4NF通过消除非平凡的多值依赖，进一步规范化关系模式，从而提高数据的完整性和一致性。\n考题类型 ","date":"2025-11-11T00:00:00+08:00","image":"https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/c7_hu_50f040dca4a75dc.png","permalink":"https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/","title":"Chapter7 分解算法(大概是7.4-7.5)"},{"content":"凸多边形最优三角剖分 凸n边形的三角剖分与n-1个叶子的语法树之间存在一一对应关系。由于n个矩阵的完全加括号乘积与n个叶子的语法树之间存在一一对应关系，因此n个矩阵的完全加括号乘积也与凸(n+1)边形的三角剖分之间存在一一对应关系。 事实上，矩阵连乘积的最优计算次序问题是凸多边形最优三角剖分问题的一个特殊情形。 对于给定的矩阵链A1A2..An，定义一个与之相应的凸(n+1)边形P={v0 ,v1 ,… ,vn}，使得矩阵Ai与凸多边形的边vi-1vi一一对应。若矩阵Ai的维数为pi-1×pi,i=1,2,…,n，则定义三角形vivjvk上的权函数值为： ω(vivjvk)=pipjpk。依此权函数的定义，凸多边形P的最优三角剖分所对应的语法树给出矩阵链A1A2..An的最优完全加括号方式。\n最优子结构性质 递归结构 ","date":"2025-11-05T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/","title":"凸多边形最优三角剖分"},{"content":"编译原理复习-概念总结 ","date":"2025-11-04T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/","title":"概念总结"},{"content":"信号量有关的同步问题 有限缓冲 1、分析需要的信号量个数\n1 2 3 Binary semaphore mutex = 1；//互斥信号量，实现对缓冲区的互斥访问 semaphore empty = n；//同步信号量，表示空闲缓冲区的数量 semaphore full = 0；//同步信号量，表示产品的数量，也即非空缓冲区的数量 2、类c代码 互斥信号量一定要放在同步信号量之后\n复杂读者-写者 普通 1 2 3 4 int r_cnt = 0; Semaphore wrt = 1; r_mutex = 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 writer(){ wait(wrt); //w signal(wrt); } reader(){ wait(r_mutex); r_cnt++; if(r_cnt == 1) wait(wrt); signal(r_mutex); //r wait(r_mutex); r_cnt--; if(r_cnt == 0) signal(wrt); signal(r_mutex); } 带队列的读-写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Semaphore q = 1; writer(){ wait(q); //逻辑不变 signal(q); } reader(){ wait(q); wait(r_mutex); r_cnt++; if(r_cnt == 1) wait(wrt); signal(r_mutex); signal(q); // 完成读计数之后就signal队列，之后你慢慢读没人管你 //r wait(r_mutex); r_cnt--; if(r_cnt == 0) signal(wrt); signal(r_mutex); } 扩展的读写者问题——最多允许M个读者同时读 四出生之家 可扩展到更多水果，核心是处理第一个和最后一个，保证盘内品种唯一\n哲学家吃屎 管程写法模板\n1 2 3 4 5 6 Monitor M{ enum {THINKING, EATING, HUNGRY} states[5]; condition self[5]; // void ... // void initialize(); } （期中）计数范围 三状态最大、最小值： 可以都在waiting，但是最多时必须有cpus个进程在running，所以ready_max = total - cpus\n","date":"2025-11-04T00:00:00+08:00","image":"https://invalidval.github.io/p/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/1_hu_6b1e720ff509cfb1.jpg","permalink":"https://invalidval.github.io/p/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/","title":"第六章 进程同步"},{"content":"关系数据库设计步骤 无损连接 有损连接：拆分再恢复时出现多余错误记录 如果R1、R2没有公共属性，则join时会退化成笛卡尔积\n规范化理论 数据依赖 在逻辑DBS设计过程中，将E-R图转换，得到面向特定应用领域的初始关系模式集。这些初始关系模式集中可能存在多种作为完整性约束的关系模式属性间的数据依赖 (Data Dependencies) 关系\n函数依赖 (Functional Dependencies, FD, §7.2) 多值依赖 (Mutivalued Dependencies, MVD, §7.4, 7.6) 连接依赖 (Join Dependencies, JD) （略） 函数依赖是特殊的多值依赖 多值依赖又是连接依赖的特例\n范式关系 保证关系模式的函数无损连接性、函数依赖保持性进行关系规范化处理即模式分解 1NF 原子属性\n2NF 由1NF消除非主属性对键的部分（函数）依赖得到 不包含非主属性对键的部分依赖\n3NF 由2NF消除非主属性对键的传递依赖得到 不包含非主属性的对键的部分、传递依赖\nBCNF 由3NF消除主属性对键的部分和传递依赖得到 不包含主属性、非主属性对键的部分和传递依赖\n4NF 由BCNF消除非平凡且非函数依赖的多值依赖得到\n5NF 由4NF消除非平凡的连接依赖得到\n概念 函数依赖 可参考 Chapter 7 函数依赖\n函数依赖保持 区分satisfy与holds on 满足是局部满足，保持是所有合法关系实例都必须满足此FD 平凡FD 主属性与传递依赖 部分依赖 左端非最小化\n函数依赖闭包$F^{+}$ 目的：从已知函数依赖，推导出全部隐含函数依赖\n函数依赖定义的无损连接分解 范式 1NF 所有属性都是原子的 A relational schema R is in first normal form if the domains of all attributes of R are atomic. 比如应该把学院放进属性列而非使用学号编码\n2NF 不存在非主属性对候选键的部分依赖 非主属性要么不依赖，要么完全依赖于候选键\nBCNF 不存在非主属性、主属性对候选键的部分、传递依赖 A relation schema R is in BCNF with respect to a set F of functional dependencies, if for all functional dependencies in $F^{+}$ of the form $\\alpha \\rightarrow \\beta$ where $\\alpha \\subset \\beta $ R and $\\beta \\subseteq R$, at least one of the following holds: $\\alpha \\rightarrow \\beta$ is trivial (i.e., $\\beta \\subseteq \\alpha$) $\\alpha$ is a superkey for R 如何分解成BCNF？ 说白了就是让不属于原模式超键的属性都变为新模式的主键，并从原模式中去掉依赖式右端的属性\n分解BCNF也存在函数依赖保持和非保持 总之就一句话： the functional dependency s_ID, dept name → i_ID can only be checked by computing the join of the decomposed relations\n3NF Because it is not always possible to achieve both BCNF and dependency preservation, we consider a weaker normal form, known as third normal form (3NF). A relation schema R is in third normal form with respect to a set F of functional dependencies, if for all functional dependencies in $F^{+}$ of the form $\\alpha \\rightarrow \\beta$ where $\\alpha \\subset \\beta $ R and $\\beta \\subseteq R$, at least one of the following holds: $\\alpha \\rightarrow \\beta$ is trivial (i.e., $\\beta \\subseteq \\alpha$) $\\alpha$ is a superkey for R Each attribute A in $\\beta - \\alpha$ is part of some candidate key for R If a relation is in BCNF, it is also in 3NF (since in BCNF one of the first two conditions above must hold). Third condition is a minimal relaxation（放宽） of BCNF to ensure dependency preservation (will see why later) 3NF缺点 Redundancy in 3NF【缺点:数据冗余】\n3NF对比BCNF Advantages to 3NF over BCNF\nIt is always possible to obtain a 3NF design without sacrificing losslessness or dependency preservation 3NF分解可以保证无损连接、函数依赖保持 BCNF分解保证无损连接，但不保证函数依赖保持 Disadvantages to 3NF\nWe may have to use null values to represent some of the possible meaningful relationships among data items. There is the problem of repetition of information 分解目标 分解要求：从函数依赖角度 1. 分解为2NF, 3NF, BCNF 2. 必修保证无损连接分解，尽可能保证函数依赖保持\n","date":"2025-11-01T00:00:00+08:00","image":"https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/c7_hu_1e16304a6303a4b4.png","permalink":"https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/","title":"Chapter7 关系规范化(7.1-7.3)"},{"content":"ISA关系（6.8） ISA Relationship 指的是一种特定的数据建模技术，用于在概念模型（如ER图）中表示实体之间的继承关系。\nISA 是 “IS-A” 的缩写，例如 “A Manager IS-AN Employee”（一个经理 是 一个员工）。它描述了一种父类型（超类型） 和子类型 之间的层次关系。\n核心概念 在数据库设计中，ISA关系用于捕捉现实世界中存在的分类结构。\n超类型 / 父类： 一个更一般化、更抽象的实体。 例如：人(Person)、账户(Account)、车辆(Vehicle) 子类型 / 子类： 一个更具体、更特化的实体，它是超类型的一种。 例如：员工(Employee) 和 学生(Student) 是 人(Person) 的子类型。 储蓄账户(SavingsAccount) 和 支票账户(CheckingAccount) 是 账户(Account) 的子类型。 ISA关系的两个关键约束 当你在设计中使用ISA关系时，必须定义两个重要的约束：\n1. 重叠约束（Disjoint/Overlapping Constraint） 规定一个超类型的实例是否可以同时属于多个子类型。\n不允许重叠： 一个超类实例只能属于一个子类型。 例如：一个 账户(Account) 要么是 储蓄账户(SavingsAccount)，要么是 支票账户(CheckingAccount)，但不能同时是两者。用 “OR” 表示。 允许重叠： 一个超类实例可以同时属于多个子类型。 例如：一个 人(Person) 可以同时是 员工(Employee) 和 学生(Student)。用 “AND” 表示。 2. 完备性约束（Completeness constraint） 规定超类型中的每一个实例是否都必须至少属于一个子类型。\n全完备性（total）： 超类型的每一个实例都必须是某个子类型的实例。 例如：公司规定，每一个 员工(Employee) 都必须是 小时工(HourlyEmployee) 或 月薪工(SalariedEmployee) 中的一种。超类型 员工(Employee) 不会存在不属于任何子类的“孤例”。在ER图中，用双线表示。 部分完备性（partial）： 超类型的实例可以不属于任何子类型。 例如：一个 人(Person) 可以只是普通人，既不是 员工(Employee)，也不是 学生(Student)。在ER图中，用单线表示。 在数据库中的实现方式 ISA层次结构在物理数据库中主要有三种实现方式：\r1. 每个具体类一张表 方法： 忽略超类型，只为每个子类型创建一张表。这张表包含该子类型特有的属性，以及从超类型继承来的所有属性。 举例： 创建 学生表(Students) 和 员工表(Employees)，没有 人表(Persons)。Students表中有 student_id, name, age, major 等字段。 优点： 查询特定子类型的数据时速度快。 缺点： 数据冗余（如果一个人既是学生又是员工，他的name和age信息会在两张表中重复存储）。 难以对所有人进行统一查询（需要UNION操作）。 无法表示不属于任何子类的人。 2. 单张表 方法： 将整个层次结构“扁平化”为一张表。这张表包含超类型和所有子类型的所有属性。同时，增加一个“类型鉴别”字段来标识每一行属于哪个子类型。 举例： 创建一张 人表(Persons)，包含字段：person_id, name, age, person_type, major, salary, department。 如果 person_type = ‘Student’，那么 major 字段有意义，salary 字段为NULL。 如果 person_type = ‘Employee’，那么 salary 字段有意义，major 字段为NULL。 优点： 统一查询非常简单，不需要JOIN操作。 缺点： 表中存在大量NULL值，浪费存储空间。 表结构会随着子类型的增加而变得非常庞大和复杂。 3. 超类型和子类型分别建表 方法： 为超类型和每一个子类型都创建一张表。 超类型表包含所有实例共享的公共属性（和一个主键）。 子类型表只包含其特有的属性，并共享超类型表的主键（即子类型表的主键同时也是引用超类型表的外键）。 举例： 人表(Persons)：person_id (PK), name, age 学生表(Students)：person_id (PK, FK references Persons), major 员工表(Employees)：person_id (PK, FK references Persons), salary, department 优点： 设计规范，消除了数据冗余。 易于添加新的子类型。 能很好地支持重叠约束（一个人可以同时在Students和Employees表中有记录）。 缺点： 查询数据时需要频繁使用JOIN操作，性能可能成为瓶颈。 总结 在数据库领域中，ISA Relationship 是一个强大的概念建模工具，它清晰地表达了 “是一个” 的继承关系。理解并正确定义其重叠约束和完备性约束至关重要，因为它直接影响到最终数据库表结构的设计选择（每种实现方式都有其优缺点，需要根据具体应用场景进行权衡）。\n","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter-6.8-isa/","title":"Chapter 6.8 ISA"},{"content":"Chapter 6 The Entity-Relationship Model Entity Sets（实体集，实体型） 一张学生表是一个实体集，一个学生是一个实体（一行记录）\nRelationship Sets(关系集) 选课表就是一个关系集。它定义了“学生”和“课程”之间的“选修”这种关系。关系表示特定实体之间的一次具体关联。它对应的是联系表中的一行记录。 关系集也可以拥有自己的属性（关系集属性），用于描述关系的特征。它同样对应联系表中的列。选课表这个关系集可以有成绩、选修日期等属性，这些属性不属于学生，也不属于课程，而是属于“选修”这个行为本身。\nChoice of Primary key for Binary Relationship 在多的那一端把一的主键拿过来当外键\n多元联系(non-binary) 先转成多个二元联系再转表：将其他实体集的主键和关系自身属性建成表，各实体集不存放多余属性。\nE-R图（概念设计结果） Representing Cardinality Constraints in ER Diagram →：一 —：多 (one,many) x (one,many) = 4 种\n参与约束(Participant Constraints) 完全参与、部分参与\n逻辑设计阶段 E-R图转关系模式 实体、联系、属性（单值属性、多值属性、复合属性）如何转表？ 多值属性单独转表 复合属性拆开（如时间、地址）\n弱实体集、强实体集； 用实体还是属性？ Not to use the primary-key of an entity set as an attributes of another entity set (to represent implicitly association between these two entity sets), it is better to use an relationship set to explicitly show this association e.g. for the entity student, do not use instructor.id as its attribute, in stead of, representing association among student and instructor using relationship advisor.\n用实体还是关系？“动作”对应“联系”\n扩展ER （详情看ISA那篇） 面向对象ER：Object-oriented (OO) E-R specialization （特化，特殊化，例化） 自上而下，底层实体集是高层实体集的真子集 高层：超类；底层：子类\ngeneralization (概括化，泛化，普遍化) 自底向上\nattributes inheritance （属性继承） 联系也可以继承\nAggregation relationship on relationship（联系的联系）\nER图记号总结 ","date":"2025-10-23T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/","title":"Chapter6 ER模型"},{"content":" 一、 基础查询 (Basic Queries) 1. SELECT \u0026amp; FROM 1 2 SELECT * FROM employees; SELECT name, salary FROM employees; 2. WHERE 条件筛选 1 2 3 4 5 SELECT * FROM employees WHERE salary \u0026gt; 5000; SELECT * FROM employees WHERE department = \u0026#39;IT\u0026#39; AND salary \u0026gt; 6000; SELECT * FROM employees WHERE name LIKE \u0026#39;A%\u0026#39;; -- 名字以A开头 SELECT * FROM employees WHERE age BETWEEN 25 AND 35; SELECT * FROM employees WHERE department IN (\u0026#39;IT\u0026#39;, \u0026#39;HR\u0026#39;, \u0026#39;Finance\u0026#39;); 3. ORDER BY 排序 1 2 SELECT * FROM employees ORDER BY salary DESC; SELECT * FROM employees ORDER BY department ASC, salary DESC; 4. DISTINCT 去重 1 SELECT DISTINCT department FROM employees; 二、 聚合函数与分组 (Aggregation \u0026amp; Grouping) 5. 聚合函数 1 2 3 4 5 6 7 SELECT COUNT(*) as total_employees, AVG(salary) as avg_salary, MAX(salary) as max_salary, MIN(salary) as min_salary, SUM(salary) as total_salary FROM employees; 6. GROUP BY 分组 1 2 3 4 5 6 SELECT department, COUNT(*) as emp_count, AVG(salary) as avg_salary FROM employees GROUP BY department; 7. HAVING 分组后筛选 1 2 3 4 5 6 SELECT department, COUNT(*) as emp_count FROM employees GROUP BY department HAVING COUNT(*) \u0026gt; 5; 三、 多表连接 (Joins) 8. INNER JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e INNER JOIN departments d ON e.department_id = d.id; 9. LEFT/RIGHT JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e LEFT JOIN departments d ON e.department_id = d.id; 10. FULL OUTER JOIN 1 2 3 SELECT e.name, d.department_name FROM employees e FULL OUTER JOIN departments d ON e.department_id = d.id; 11. 多表连接 1 2 3 4 SELECT e.name, d.department_name, p.project_name FROM employees e JOIN departments d ON e.department_id = d.id JOIN projects p ON e.id = p.leader_id; 四、 子查询 (Subqueries) 12. 标量子查询 1 2 3 SELECT name, salary, (SELECT AVG(salary) FROM employees) as company_avg FROM employees; 13. IN 子查询 1 2 3 4 5 SELECT name FROM employees WHERE department_id IN ( SELECT id FROM departments WHERE budget \u0026gt; 100000 ); 14. EXISTS 子查询 1 2 3 4 5 6 SELECT name FROM employees e WHERE EXISTS ( SELECT 1 FROM projects p WHERE p.leader_id = e.id ); 15. 关联子查询 1 2 3 4 5 6 7 SELECT name, salary, department FROM employees e1 WHERE salary \u0026gt; ( SELECT AVG(salary) FROM employees e2 WHERE e2.department = e1.department ); 五、 高级查询技术 (Advanced Techniques) 16. CTE (公用表表达式) 1 2 3 4 5 6 7 8 WITH department_stats AS ( SELECT department, AVG(salary) as avg_salary FROM employees GROUP BY department ) SELECT * FROM department_stats WHERE avg_salary \u0026gt; 6000; 17. 递归 CTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 WITH RECURSIVE org_chart AS ( -- 基础情况 SELECT employee_id, name, manager_id, 1 as level FROM employees WHERE manager_id IS NULL UNION ALL -- 递归情况 SELECT e.employee_id, e.name, e.manager_id, oc.level + 1 FROM employees e JOIN org_chart oc ON e.manager_id = oc.employee_id ) SELECT * FROM org_chart; 18. 窗口函数 1 2 3 4 5 6 7 8 SELECT name, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank, AVG(salary) OVER (PARTITION BY department) as dept_avg_salary, LAG(salary) OVER (ORDER BY salary) as prev_salary FROM employees; 19. PIVOT 行列转换 1 2 3 4 5 6 7 8 9 10 -- SQL Server SELECT * FROM ( SELECT department, salary FROM employees ) AS SourceTable PIVOT ( AVG(salary) FOR department IN ([IT], [HR], [Finance]) ) AS PivotTable; 六、 数据操作 (Data Manipulation) 20. INSERT 1 2 3 4 5 6 INSERT INTO employees (name, salary, department) VALUES (\u0026#39;John Doe\u0026#39;, 5000, \u0026#39;IT\u0026#39;); -- 插入查询结果 INSERT INTO high_paid_employees (name, salary) SELECT name, salary FROM employees WHERE salary \u0026gt; 8000; 21. UPDATE 1 2 3 4 5 6 7 8 9 10 UPDATE employees SET salary = salary * 1.1 WHERE department = \u0026#39;IT\u0026#39;; -- 使用子查询更新 UPDATE employees SET salary = ( SELECT AVG(salary) FROM employees ) WHERE salary IS NULL; 22. DELETE 1 2 3 4 5 6 7 DELETE FROM employees WHERE salary \u0026lt; 3000; -- 使用子查询删除 DELETE FROM employees WHERE department_id IN ( SELECT id FROM departments WHERE active = 0 ); 23. MERGE/UPSERT 1 2 3 4 5 -- PostgreSQL INSERT INTO employees (id, name, salary) VALUES (1, \u0026#39;John\u0026#39;, 5000) ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, salary = EXCLUDED.salary; 七、 事务控制 (Transaction Control) 24. 事务处理 1 2 3 4 5 6 7 8 9 10 BEGIN TRANSACTION; UPDATE accounts SET balance = balance - 100 WHERE id = 1; UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 如果一切正常 COMMIT; -- 如果出现错误 ROLLBACK; 八、 性能优化相关 25. 索引使用 1 2 CREATE INDEX idx_employee_department ON employees(department); CREATE INDEX idx_employee_name_salary ON employees(name, salary); 26. 分页查询 1 2 3 4 5 -- MySQL SELECT * FROM employees ORDER BY id LIMIT 10 OFFSET 20; -- SQL Server SELECT * FROM employees ORDER BY id OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY; 27. 查询性能分析 1 2 3 4 5 6 -- 查看执行计划 EXPLAIN SELECT * FROM employees WHERE salary \u0026gt; 5000; -- SQL Server SET STATISTICS TIME ON; SELECT * FROM employees WHERE salary \u0026gt; 5000; 九、 实用函数 28. 字符串函数 1 2 3 4 5 6 7 SELECT UPPER(name) as upper_name, LOWER(name) as lower_name, LENGTH(name) as name_length, SUBSTRING(name, 1, 3) as name_prefix, CONCAT(first_name, \u0026#39; \u0026#39;, last_name) as full_name FROM employees; 29. 日期函数 1 2 3 4 5 6 SELECT CURRENT_DATE as today, EXTRACT(YEAR FROM hire_date) as hire_year, DATE_ADD(hire_date, INTERVAL 1 YEAR) as anniversary, DATEDIFF(CURRENT_DATE, hire_date) as days_employed FROM employees; 30. 条件表达式 1 2 3 4 5 6 7 8 9 10 SELECT name, salary, CASE WHEN salary \u0026lt; 3000 THEN \u0026#39;Low\u0026#39; WHEN salary BETWEEN 3000 AND 7000 THEN \u0026#39;Medium\u0026#39; ELSE \u0026#39;High\u0026#39; END as salary_level, COALESCE(bonus, 0) as bonus_amount FROM employees; 这份指南涵盖了 SQL 从基础到高级的大部分常用语法。建议在实际工作中根据需要查阅相关部分，并通过练习来熟练掌握。\n","date":"2025-10-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter-3-5-sql-%E8%BF%9B%E9%98%B6%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/","title":"Chapter 3-5 SQL 进阶查询语法大全"},{"content":"NOT EXISTS 和 EXCEPT 是 SQL 中用于处理集合差集的高级操作，它们在不同场景下非常有用。\n一、 NOT EXISTS 用法 1. 基本语法 1 2 3 4 5 6 7 SELECT columns FROM table1 t1 WHERE NOT EXISTS ( SELECT 1 FROM table2 t2 WHERE t1.related_column = t2.related_column ); 2. 实际例子 例1：找出没有项目的员工 1 2 3 4 5 6 7 SELECT e.employee_id, e.name FROM employees e WHERE NOT EXISTS ( SELECT 1 FROM projects p WHERE p.leader_id = e.employee_id ); 例2：找出没有订单的客户 1 2 3 4 5 6 7 SELECT c.customer_id, c.customer_name FROM customers c WHERE NOT EXISTS ( SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id ); 例3：找出从未被订购的产品 1 2 3 4 5 6 7 SELECT p.product_id, p.product_name FROM products p WHERE NOT EXISTS ( SELECT 1 FROM order_items oi WHERE oi.product_id = p.product_id ); 3. 复杂例子：找出没有下属的管理者 1 2 3 4 5 6 7 8 SELECT e1.employee_id, e1.name FROM employees e1 WHERE e1.is_manager = 1 AND NOT EXISTS ( SELECT 1 FROM employees e2 WHERE e2.manager_id = e1.employee_id ); 二、 EXCEPT 用法 1. 基本语法 1 2 3 SELECT column1, column2 FROM table1 EXCEPT SELECT column1, column2 FROM table2; 2. 实际例子 例1：找出只在A表不在B表的记录 1 2 3 4 -- 找出在employees表但不在former_employees表的员工 SELECT employee_id, name FROM employees EXCEPT SELECT employee_id, name FROM former_employees; 例2：找出有库存但从未被订购的产品 1 2 3 SELECT product_id FROM inventory EXCEPT SELECT product_id FROM order_items; 例3：多列比较 1 2 3 4 -- 找出在2023年有销售但2024年没有的客户 SELECT customer_id, product_id FROM sales_2023 EXCEPT SELECT customer_id, product_id FROM sales_2024; 三、 NOT EXISTS vs EXCEPT 对比 相同需求的不同实现 需求：找出没有项目的部门 使用 NOT EXISTS:\n1 2 3 4 5 6 7 SELECT d.department_id, d.department_name FROM departments d WHERE NOT EXISTS ( SELECT 1 FROM projects p WHERE p.department_id = d.department_id ); 使用 EXCEPT:\n1 2 3 4 5 6 SELECT department_id, department_name FROM departments EXCEPT SELECT d.department_id, d.department_name FROM departments d JOIN projects p ON d.department_id = p.department_id; 四、 高级应用场景 1. 多层 NOT EXISTS（复杂逻辑） 找出所有产品都库存充足的产品类别 1 2 3 4 5 6 7 8 9 SELECT c.category_id, c.category_name FROM categories c WHERE NOT EXISTS ( -- 找出该类别中库存不足的产品 SELECT 1 FROM products p WHERE p.category_id = c.category_id AND p.current_stock \u0026lt; p.minimum_stock ); 2. EXCEPT 用于数据验证 验证两个表的结构一致性 1 2 3 4 -- 找出在source_table中存在但在target_table中不存在的记录 SELECT id, name, value FROM source_table EXCEPT SELECT id, name, value FROM target_table; 3. 组合使用 NOT EXISTS 和 EXISTS 找出只订购过一次的客户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT c.customer_id, c.customer_name FROM customers c WHERE EXISTS ( -- 至少有一个订单 SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id ) AND NOT EXISTS ( -- 没有第二个订单 SELECT 1 FROM orders o1, orders o2 WHERE o1.customer_id = c.customer_id AND o2.customer_id = c.customer_id AND o1.order_id \u0026lt;\u0026gt; o2.order_id ); 五、 性能考虑和最佳实践 1. NOT EXISTS 通常性能更好 1 2 3 4 5 6 7 -- 推荐：使用NOT EXISTS SELECT * FROM table1 t1 WHERE NOT EXISTS (SELECT 1 FROM table2 t2 WHERE t2.id = t1.id); -- 不推荐：使用NOT IN（对NULL值处理有问题） SELECT * FROM table1 WHERE id NOT IN (SELECT id FROM table2 WHERE id IS NOT NULL); 2. EXCEPT 自动去重 1 2 3 4 -- EXCEPT 会自动去除重复记录 SELECT department FROM employees EXCEPT SELECT department FROM former_employees; 3. 处理NULL值 1 2 3 4 5 6 -- NOT EXISTS 能正确处理NULL值 SELECT * FROM products p WHERE NOT EXISTS ( SELECT 1 FROM discontinued_products dp WHERE dp.product_id = p.product_id ); 六、 实际业务场景 场景1：电商平台 - 找出从未被浏览的商品 1 2 3 4 5 6 7 SELECT product_id, product_name FROM products WHERE NOT EXISTS ( SELECT 1 FROM user_browsing_history WHERE product_id = products.product_id ); 场景2：学校系统 - 找出没有选课的学生 1 2 3 4 5 6 SELECT student_id, student_name FROM students EXCEPT SELECT s.student_id, s.student_name FROM students s JOIN enrollments e ON s.student_id = e.student_id; 场景3：银行系统 - 找出有账户但从未交易的客户 1 2 3 4 5 6 7 8 SELECT c.customer_id, c.customer_name FROM customers c JOIN accounts a ON c.customer_id = a.customer_id WHERE NOT EXISTS ( SELECT 1 FROM transactions t WHERE t.account_id = a.account_id ); 总结 NOT EXISTS: 更适合关联查询，性能通常较好，能正确处理NULL值 EXCEPT: 更适合比较两个结果集的差异，语法更直观，自动去重 选择依据: 需要关联条件时用 NOT EXISTS 直接比较两个查询结果时用 EXCEPT 考虑数据库优化器和具体数据量进行测试 两者都是处理\u0026quot;在A中但不在B中\u0026quot;这类需求的强大工具！\n","date":"2025-10-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter3-sql%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/","title":"Chapter3 SQL集合操作"},{"content":"SQL 语法 SELECT distinct 去重 1 2 select `distinct/all` dept_name from instructor 四则运算和重命名 1 select ID, name, salary/12 as monthly_salary FROM natural join 自然连接 1 2 3 4 select name, course_id from instructor natural join teaches where instructor. dept_name = ‘Art’ // 等价于加上 where instructor.ID = teaches.ID and WHERE SQL allows the use of the logical connectives and, or, and not The operands of the logical connectives can be expressions involving the comparison operators \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, =, and \u0026lt;\u0026gt;.（以及between A and B 用法）\nTuple comparison 1 2 3 select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, \u0026#39;Biology\u0026#39;); Tuple Variables 涉及到对instructor关系中属性salary的不同值的比较\n1 2 3 select distinct T.name from instructor as T, instructor as S where T.salary \u0026gt; S.salary and S.dept_name = ‘Comp. Sci.’ 执行顺序 FROM - 从表中获取数据\nWHERE - 对原始行数据进行筛选\nGROUP BY - 对筛选后的数据进行分组\nHAVING - 对分组后的聚合结果进行筛选\nSELECT - 选择要显示的列\n在 WHERE 子句中不能直接使用 COUNT 等聚合函数，因为执行顺序的问题。\n1 2 3 4 5 -- ✅ 正确：使用HAVING对分组结果进行筛选 SELECT department, COUNT(*) as emp_count FROM employees GROUP BY department HAVING COUNT(*) \u0026gt; 5; -- 这里COUNT()在每组内计算 CTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 WITH department_stats AS ( SELECT department, AVG(salary) as avg_salary, COUNT(*) as employee_count FROM employees GROUP BY department ), high_avg_departments AS ( -- 这个CTE引用了前一个CTE SELECT department, avg_salary FROM department_stats WHERE avg_salary \u0026gt; 6000 ) -- 主查询 SELECT e.name, e.salary, h.avg_salary as department_avg FROM employees e JOIN high_avg_departments h ON e.department = h.department WHERE e.salary \u0026gt; h.avg_salary; GROUP BY Attributes in select clause outside of aggregate functions must appear in group by list（必须要有聚合运算） 错误示例：\n1 2 3 4 /* erroneous query */ select dept_name, ID, avg (salary) -- ID 不在聚合属性中 from instructor group by dept_name 正确用法：（可以有多个聚合运算）\nproduct category sales_amount A Electronics 100 B Electronics 150 A Electronics 200 C Clothing 80 B Electronics 120 1 2 3 4 5 6 SELECT category, COUNT(*) as transaction_count, SUM(sales_amount) as total_sales FROM sales GROUP BY category; category transaction_count total_sales Electronics 4 570 Clothing 1 80 常用聚合函数\n1 2 3 4 5 6 7 8 9 SELECT department, COUNT(*) as employee_count, -- 计数 AVG(salary) as avg_salary, -- 平均值 SUM(salary) as total_salary, -- 求和 MAX(salary) as max_salary, -- 最大值 MIN(salary) as min_salary -- 最小值 FROM employees GROUP BY department; ORDER BY 1 2 SELECT * FROM employees ORDER BY salary DESC; SELECT * FROM employees ORDER BY department ASC, salary DESC; ","date":"2025-09-30T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter3-intro-to-sql/","title":"Chapter3 Intro-to-SQL"},{"content":"\\o/ \\o/ \\o/\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/blog%E4%BA%8C%E5%91%A8%E7%9B%AE%E6%AD%A3%E5%BC%8F%E4%B8%8A%E7%BA%BF/","title":"blog二周目正式上线"},{"content":"关系数据库结构 table、relation、attributes\nkey A superkey (超键) is a set of one or more attributes that, taken collectively, can be used to identify uniquely a tuple in the relation.\nK is a candidate key (候选键) if K is minimal super key. e.g.{ID} is a candidate key for instructor, assuming no two instructors can possibly have the same identifiers. A relation may have several candidate keys\nPrimary key (主键) is a candidate key chosen by the database designer as principal means to identify tuples within a relation\nDef. Primary attributes (主属性!) taking the key as a attribute set, the attributes in the candidate keys, i.e. the element of the primary key is called the primary attributes non-primary attributes (非主属性)\nSuper key \u0026gt;= candidate key \u0026gt;= primary key\nrelational algebra (关系代数) Six basic operators (选择) select: $\\sigma$ (投影) project: (笛卡尔积) Cartesian product: x (集合并) union: (集合差) set difference: – (重命名) rename: 复合关系运算 暂时值（Assignment） ","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","title":"Chapter2 关系数据库基础"},{"content":"思想 递归\n分治的条件 规模缩小到一定程度可以容易解决 具有最优子结构性质 子问题的解可以合并为该问题的解（与动态规划的区别）（不能：贪心、DP） 不包含公共子问题（各个子问题相互独立，否则使用DP） 快速排序：原地排序、$nlogn$ 2.3 二分搜索 2.4 大整数乘法 2.5 Strassen矩阵乘法 2.7 合并排序 2.8 快速排序 2.9 选择问题 长度为$n$线性有序集合，找出第$k$小 分治，$pivot$ 线性时间选择问题，问题规模 $0\u0026lt;\\epsilon\u0026lt;1$\n步骤 划分成$\\frac{n}{5}$个组 各组内任意排序 每组中，$pivot_{i}$ = 中位数 一共$\\frac{n}{5}$个$pivot$，再找出中位数 只有75个元素以上才能缩小$\\frac{1}{4}$ 补充 划分因子选择3、7：7可以，3不行\n2.10 最近点对问题 直线 暴力$O(n^{2})$ 一次排序、一维扫描，$O(nlogn)$\n二维 蛮力；分治（平衡子问题） 如何分治？能在线性时间内完成？\n","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E5%88%86%E6%B2%BB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"分治基本概念"},{"content":"分治 左侧从右向左，右侧从左向右\nDP 从前向后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void MAXSUB(int a[], int n){ int *b = new int[MAX]; int *rec = new int[max]; b[0] = a[0]; rec[0] = 0; int max = b[0]; for(int i = 1; i \u0026lt; n; i++){ if(b[i-1] \u0026gt; 0) { b[i] = b[i-1] + a[i]; rec = rec[i-1]; } else{ b[i] = a[i]; rec = i; } if(b[i] \u0026gt; max) max = b[i]; } } ","date":"2023-01-01T00:00:00+08:00","permalink":"https://invalidval.github.io/p/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/","title":"最大子段和"}]