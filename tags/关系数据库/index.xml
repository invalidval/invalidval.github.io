<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>关系数据库 on zcys univ II Hugo ver</title>
        <link>https://invalidval.github.io/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <description>Recent content in 关系数据库 on zcys univ II Hugo ver</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Tue, 11 Nov 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://invalidval.github.io/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Chapter7 分解算法(大概是7.4-7.5)</title>
        <link>https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/</link>
        <pubDate>Tue, 11 Nov 2025 00:00:00 +0800</pubDate>
        
        <guid>https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/</guid>
        <description>&lt;img src="https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/c7.png" alt="Featured image of post Chapter7 分解算法(大概是7.4-7.5)" /&gt;&lt;h2 id=&#34;functional-dependency-theory&#34;&gt;Functional-Dependency Theory
&lt;/h2&gt;&lt;h3 id=&#34;sql-for-judging-fds&#34;&gt;SQL for judging FDs
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image.png&#34;
	width=&#34;1170&#34;
	height=&#34;531&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image_hu_fbbf3765274fc645.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image_hu_3685a5474aacfa59.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;断言&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;528px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-1.png&#34;
	width=&#34;1164&#34;
	height=&#34;516&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-1_hu_644ef2888ce87e8e.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-1_hu_99d8e10ad593effd.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;元组变量&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;closure-of-a-set-of-functional-dependencies&#34;&gt;Closure of a Set of Functional Dependencies
&lt;/h3&gt;&lt;p&gt;The set of all functional dependencies &lt;strong&gt;logically implied&lt;/strong&gt; by F is the closure of F, which is denoted as F+. It is the set of all functional dependencies that can be inferred from F using Armstrong&amp;rsquo;s axioms. These axioms include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reflexivity: If Y ⊆ X, then X → Y holds.&lt;/li&gt;
&lt;li&gt;Augmentation: If X → Y holds, then XZ → YZ holds for any Z.&lt;/li&gt;
&lt;li&gt;Transitivity: If X → Y and Y → Z hold, then X → Z holds.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;armstrongs-axioms&#34;&gt;Armstrong&amp;rsquo;s Axioms
&lt;/h3&gt;&lt;p&gt;Armstrong&amp;rsquo;s axioms are a set of rules used to infer all the functional dependencies in a relational database. They are sound (i.e., they only produce valid dependencies) and complete (i.e., they can produce all valid dependencies).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reflexivity: If Y is a subset of X, then X → Y holds.&lt;/li&gt;
&lt;li&gt;Augmentation: If X → Y holds, then XZ → YZ holds for any Z.&lt;/li&gt;
&lt;li&gt;Transitivity: If X → Y and Y → Z hold, then X → Z holds.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;additional-rules&#34;&gt;Additional Rules
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Union: If X → Y and X → Z hold, then X → YZ holds.&lt;/li&gt;
&lt;li&gt;Decomposition: If X → YZ holds, then X → Y and X → Z hold.&lt;/li&gt;
&lt;li&gt;Pseudotransitivity: If X → Y and YZ → W hold, then XZ → W holds. （可由先argumentation和transitivity推导出）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;属性集闭包&#34;&gt;属性集闭包
&lt;/h2&gt;&lt;p&gt;属性集X在函数依赖集F下的闭包，记为X+，是指在F中可以由X推导出的所有属性的集合。
计算X+的算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化X+为X。&lt;/li&gt;
&lt;li&gt;重复以下步骤，直到X+不再变化：
&lt;ul&gt;
&lt;li&gt;对于F中的每个函数依赖A → B，如果A是X+的子集，则将B添加到X+中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子
&lt;/h3&gt;&lt;p&gt;设有关系R(A, B, C, D)和函数依赖集F =
{A → B, B → C}，计算属性集A的闭包A+：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化A+ = {A}。&lt;/li&gt;
&lt;li&gt;应用A → B，因为A是A+的子集，添加B到A+，得到A+ = {A, B}。&lt;/li&gt;
&lt;li&gt;应用B → C，因为B是A+的子集，添加C到
A+，得到A+ = {A, B, C}。&lt;/li&gt;
&lt;li&gt;没有更多的函数依赖可以应用，算法终止。
最终，A+ = {A, B, C}。
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-2.png&#34;
	width=&#34;1772&#34;
	height=&#34;768&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-2_hu_933f2dfe75ba76be.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-2_hu_8b280a5ce04fff6b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;属性闭包例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;230&#34;
		data-flex-basis=&#34;553px&#34;
	
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;canonical-cover最简函数依赖集&#34;&gt;Canonical Cover【最简函数依赖集】
&lt;/h2&gt;&lt;p&gt;函数依赖集F的规范覆盖（Canonical Cover），记为Fc，是一个等价于F的最小函数依赖集。规范覆盖具有以下性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个函数依赖的右侧只有一个属性。&lt;/li&gt;
&lt;li&gt;没有冗余的函数依赖。&lt;/li&gt;
&lt;li&gt;没有冗余的属性在函数依赖的左侧。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;计算规范覆盖的步骤&#34;&gt;计算规范覆盖的步骤
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;将每个函数依赖的右侧拆分为单个属性。&lt;/li&gt;
&lt;li&gt;移除冗余的函数依赖。&lt;/li&gt;
&lt;li&gt;移除冗余的属性在函数依赖的左侧。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;例子-1&#34;&gt;例子
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-3.png&#34;
	width=&#34;1782&#34;
	height=&#34;1019&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-3_hu_678d161d910204b9.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-3_hu_cd9fc73393e31cc8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Fc计算&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;419px&#34;
	
&gt;。&lt;/p&gt;
&lt;h2 id=&#34;extraneous-attributes冗余属性&#34;&gt;Extraneous Attributes（冗余属性）
&lt;/h2&gt;&lt;p&gt;在函数依赖X → Y中，如果存在属性A ∈ X，使得在去掉A后，X - {A} → Y仍然成立，则称A是冗余属性。&lt;/p&gt;
&lt;h3 id=&#34;例子-2&#34;&gt;例子
&lt;/h3&gt;&lt;p&gt;设有函数依赖集F = {AB → C, A → B}，检查属性A在AB → C中是否冗余：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算B的闭包B+：
&lt;ul&gt;
&lt;li&gt;初始化B+ = {B}。&lt;/li&gt;
&lt;li&gt;没有函数依赖可以应用，B+ = {B}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查是否B+包含C：
&lt;ul&gt;
&lt;li&gt;B+不包含C，因此A不是冗余属性。
最终，属性A在AB → C中不是冗余属性。
对于右端冗余属性的检查：
在函数依赖X → Y中，如果存在属性B ∈ Y，使得在去掉B后，X → Y - {B}仍然成立，则称B是冗余属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;移除左端冗余属性，得到更强的函数依赖【所需左端前提条件更少】
移除右端冗余属性，得到更弱的函数依赖【结论更少】&lt;/p&gt;
&lt;p&gt;一个依赖关系under F的意思是可以从F中推导出该依赖关系&lt;/p&gt;
&lt;h2 id=&#34;dependency-preservation依赖保持&#34;&gt;Dependency Preservation（依赖保持）
&lt;/h2&gt;&lt;p&gt;在关系模式分解中，如果分解后的每个子模式的函数依赖集的联合能够推导出原始模式的所有函数依赖，则称该分解是依赖保持的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;与holds on的区别在于，
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;holds on是指某个具体的关系实例满足某个函数依赖，
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;而dependency preservation是指分解后的模式在所有可能的关系实例中都能保持原始模式的函数依赖。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-4.png&#34;
	width=&#34;1809&#34;
	height=&#34;909&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-4_hu_22e9e7391756f43f.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-4_hu_efc7da62c3ccf696.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;什么是Fi，老子也没懂&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;477px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-5.png&#34;
	width=&#34;1722&#34;
	height=&#34;836&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-5_hu_f59f776af4162e1.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-5_hu_d8c7858f2bea98b8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;preserved例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;205&#34;
		data-flex-basis=&#34;494px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-7.png&#34;
	width=&#34;1812&#34;
	height=&#34;954&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-7_hu_3f0c7a0db91ea827.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-7_hu_dc30d980fc7eace4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;cnmd&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;455px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-8.png&#34;
	width=&#34;1755&#34;
	height=&#34;981&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-8_hu_5d8013d2378b395c.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-8_hu_e9101c0a101b14a8.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;不保持分解&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-9.png&#34;
	width=&#34;1782&#34;
	height=&#34;573&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-9_hu_c08fcd348858bd9c.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-9_hu_c75f593ad4bfde3a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;保持分解&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;310&#34;
		data-flex-basis=&#34;746px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;75-algorithms-for-decomposition-using-functional-dependencies&#34;&gt;7.5 Algorithms for Decomposition Using Functional Dependencies
&lt;/h2&gt;&lt;p&gt;本节内容
BCNF
Testing for BCNF /判断关系模式是否是BCNF
Testing Decomposition for BCNF/ 判断分解后的子模式是否是BCNF
BCNF decomposition algorithm/将关系模式分解为BCNF的方法
3NF
Testing for 3NF
3NF decomposition algorithm
Comparison of BCNF and 3NF&lt;/p&gt;
&lt;h3 id=&#34;testing-for-bcnf&#34;&gt;Testing for BCNF
&lt;/h3&gt;&lt;p&gt;判断关系模式R是否是BCNF的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算函数依赖集F的规范覆盖Fc。&lt;/li&gt;
&lt;li&gt;对于Fc中的每个函数依赖X → Y，检查X是否是R的超键。&lt;/li&gt;
&lt;li&gt;如果所有函数依赖的左侧都是超键，则R是BCNF；否则，R不是BCNF。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;testing-decomposition-for-bcnf&#34;&gt;Testing Decomposition for BCNF
&lt;/h3&gt;&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the restriction of F to Ri 的意思是：
将函数依赖集F中的所有函数依赖限制在子模式Ri上，即只保留那些在Ri中有效的函数依赖。
举例子：
设有关系模式R(A, B, C)和函数依赖集F = {A → B, B → C}，将R分解为子模式R1(A, B)和R2(B, C)。
the restriction of F to R1是{A → B}，因为B → C在R1中无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试由R分解后的子模式Ri是否BCNF，不能仅凭R上的F，应该采用F+&lt;/p&gt;
&lt;h3 id=&#34;decomposition-algorithm-for-bcnf&#34;&gt;Decomposition Algorithm for BCNF
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;检查关系模式R是否是BCNF。如果是，则返回R作为分解结果。&lt;/li&gt;
&lt;li&gt;如果R不是BCNF，找到一个违反BCNF的函数依赖X → Y，其中X不是R的超键。&lt;/li&gt;
&lt;li&gt;将R分解为两个子模式R1和R2：
&lt;ul&gt;
&lt;li&gt;R1 = X ∪ Y&lt;/li&gt;
&lt;li&gt;R2 = R - Y + X&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;递归地对R1和R2应用步骤1-3，直到所有子模式都是BCNF。
Note:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;3中R1的意思是包含X和Y的所有属性的子模式，R2的意思是R中去掉Y属性后再加上X属性的子模式&lt;/li&gt;
&lt;li&gt;该算法可能不会产生依赖保持的分解。&lt;/li&gt;
&lt;li&gt;该算法确保每个子模式都是BCNF。
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-10.png&#34;
	width=&#34;1779&#34;
	height=&#34;666&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-10_hu_89ac9b91046d1cb2.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-10_hu_9543829986eb1b24.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分解例子1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;267&#34;
		data-flex-basis=&#34;641px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-11.png&#34;
	width=&#34;1764&#34;
	height=&#34;777&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-11_hu_fa01c86cb11d1cb.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-11_hu_ee10086738b5980e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分解例子2-1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;227&#34;
		data-flex-basis=&#34;544px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-14.png&#34;
	width=&#34;1791&#34;
	height=&#34;710&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-14_hu_382cae119eb7c7e8.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-14_hu_d6ea7c4da10825dd.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分解步骤树&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;252&#34;
		data-flex-basis=&#34;605px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-12.png&#34;
	width=&#34;1785&#34;
	height=&#34;609&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-12_hu_6d3f761eb69c5f7b.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-12_hu_6662cd04c3398405.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分解例子2-2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;293&#34;
		data-flex-basis=&#34;703px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-13.png&#34;
	width=&#34;1797&#34;
	height=&#34;990&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-13_hu_b9ceb1655c31af7d.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-13_hu_2a0c61b484aa2f76.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;分解例子2-3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BCNF分解不保证依赖保持&lt;/strong&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-15.png&#34;
	width=&#34;1827&#34;
	height=&#34;897&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-15_hu_edcf2ae7121d145b.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-15_hu_7dca34e770012f47.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;not preserved&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;203&#34;
		data-flex-basis=&#34;488px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;decomposition-algorithm-for-3nf&#34;&gt;Decomposition Algorithm for 3NF
&lt;/h3&gt;&lt;p&gt;为什么需要3NF分解算法？
因为BCNF分解不保证依赖保持，而3NF分解算法可以保证依赖保持。&lt;/p&gt;
&lt;p&gt;testing for 3NF has been shown to be NP-hard,
Interestingly, decomposition into third normal form (described shortly) can be done in polynomial time
算法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算函数依赖集F的规范覆盖Fc。&lt;/li&gt;
&lt;li&gt;对于Fc中的每个函数依赖X → Y，创建一个子模式R_i = X ∪ Y。&lt;/li&gt;
&lt;li&gt;如果没有子模式包含R的候选键，则添加一个子模式R_k，该子模式包含R的一个候选键。&lt;/li&gt;
&lt;li&gt;返回所有子模式作为分解结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Example of 3NF Decomposition&lt;/strong&gt;
设有关系模式R(A, B, C, D)和函数依赖集F = {A → B, B → C}，应用3NF分解算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算规范覆盖Fc = {A → B, B → C}。&lt;/li&gt;
&lt;li&gt;创建子模式：
&lt;ul&gt;
&lt;li&gt;R1 = {A, B}（对应A → B）&lt;/li&gt;
&lt;li&gt;R2 = {B, C}（对应B → C）
（R1、R2都是BCNF）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;R的候选键是{A, D}，没有子模式包含它，因此添加R3 = {A, D}。&lt;/li&gt;
&lt;li&gt;返回子模式R1, R2, R3作为分解结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要有一个候选键包含在第2步构造出的某个子模式Ri中，就无需在第3步中，为候选键单独构造子模式。
任意挑选R的一个候选键【&lt;strong&gt;只需挑选一个&lt;/strong&gt;】，对该候选健单独构造一个关系模式；无需考虑全部候选键!!!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;appendix-7-1-computing-candidate-keys&#34;&gt;Appendix 7-1 Computing Candidate Keys
&lt;/h2&gt;&lt;p&gt;计算候选键的步骤：&lt;/p&gt;
&lt;p&gt;step1. 将R的所有属性分为四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L类：仅出现在F中函数依赖左部的属性&lt;/li&gt;
&lt;li&gt;R类：仅出现在F中函数依赖右部的属性&lt;/li&gt;
&lt;li&gt;N类：在F中函数依赖左右两边均未出现的属性&lt;/li&gt;
&lt;li&gt;LR类：在F中函数依赖左右两边均出现的属性
令X_set=L类 ∪ N类，Y_set=LR类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;step2.  求X_set +，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果X_set+ =R，则X_set为R的唯一候选键，转step5；否则转step3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;step3.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Y_set中取一属性A，求(X_set ∪ A)+，若它包含了R的所有属性，则转step4; 否则，调换一属性反复进行这一过程，直到试完所有Y_set中的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;step4.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果已找出所有的候选键，则转step5;
&lt;strong&gt;否则，在Y_set中依此取两个、三个，…，求其属性闭包，直至其闭包包含R的所有的属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;step5. 停止，输出结果
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-16.png&#34;
	width=&#34;1806&#34;
	height=&#34;1002&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-16_hu_f7e35a5179194bb9.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-16_hu_3e633aab96018d48.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;180&#34;
		data-flex-basis=&#34;432px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-17.png&#34;
	width=&#34;1765&#34;
	height=&#34;1020&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-17_hu_1be38c38f57ad938.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-17_hu_f2a15f7d30448e2a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;例子-2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;173&#34;
		data-flex-basis=&#34;415px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;最后为什么需要4nf&#34;&gt;最后，为什么需要4NF
&lt;/h2&gt;&lt;p&gt;在某些情况下，关系模式可能存在多值依赖（MVD），这会导致数据冗余和更新异常。4NF通过消除非平凡的多值依赖，进一步规范化关系模式，从而提高数据的完整性和一致性。&lt;/p&gt;
&lt;h2 id=&#34;考题类型&#34;&gt;考题类型
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-18.png&#34;
	width=&#34;1800&#34;
	height=&#34;900&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-18_hu_ece034353ccd875a.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-18_hu_97495aea3edc5824.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;480px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-19.png&#34;
	width=&#34;1782&#34;
	height=&#34;792&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-19_hu_d2cc9b323dba4902.png 480w, https://invalidval.github.io/p/chapter7-%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E5%A4%A7%E6%A6%82%E6%98%AF7.4-7.5/image-19_hu_88d2609632db0c17.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;540px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Chapter7 关系规范化(7.1-7.3)</title>
        <link>https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/</link>
        <pubDate>Sat, 01 Nov 2025 00:00:00 +0800</pubDate>
        
        <guid>https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/</guid>
        <description>&lt;img src="https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/c7.png" alt="Featured image of post Chapter7 关系规范化(7.1-7.3)" /&gt;&lt;h1 id=&#34;关系数据库设计步骤&#34;&gt;关系数据库设计步骤
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-2.png&#34;
	width=&#34;1013&#34;
	height=&#34;567&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-2_hu_493d6f455a140a7f.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-2_hu_1e944343fcb1755b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;关系数据库设计内容/步骤&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;无损连接&#34;&gt;无损连接
&lt;/h1&gt;&lt;p&gt;有损连接：拆分再恢复时出现多余错误记录
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-3.png&#34;
	width=&#34;1011&#34;
	height=&#34;564&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-3_hu_1b39139cf869d3be.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-3_hu_a2f4d7abc69d7b88.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;无损连接与SQL&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;430px&#34;
	
&gt;
如果R1、R2没有公共属性，则join时会退化成笛卡尔积&lt;/p&gt;
&lt;h1 id=&#34;规范化理论&#34;&gt;规范化理论
&lt;/h1&gt;&lt;h2 id=&#34;数据依赖&#34;&gt;数据依赖
&lt;/h2&gt;&lt;p&gt;在逻辑DBS设计过程中，将E-R图转换，得到面向特定应用领域的初始关系模式集。这些初始关系模式集中可能存在多种&lt;strong&gt;作为完整性约束的&lt;/strong&gt;关系模式属性间的数据依赖 (Data Dependencies) 关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数依赖 (Functional Dependencies, FD, §7.2)
多值依赖 (Mutivalued Dependencies, MVD, §7.4, 7.6)
连接依赖 (Join Dependencies, JD) （略）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数依赖是特殊的多值依赖
多值依赖又是连接依赖的特例&lt;/p&gt;
&lt;h2 id=&#34;范式关系&#34;&gt;范式关系
&lt;/h2&gt;&lt;p&gt;保证关系模式的函数无损连接性、函数依赖保持性进行关系规范化处理&lt;strong&gt;即模式分解&lt;/strong&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-1.png&#34;
	width=&#34;2037&#34;
	height=&#34;1140&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-1_hu_72fea522126e530a.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-1_hu_76ae8d1399a3e256.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;范式定义&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;1nf&#34;&gt;1NF
&lt;/h3&gt;&lt;p&gt;原子属性&lt;/p&gt;
&lt;h3 id=&#34;2nf&#34;&gt;2NF
&lt;/h3&gt;&lt;p&gt;由1NF消除非主属性对键的部分（函数）依赖得到
不包含非主属性对键的部分依赖&lt;/p&gt;
&lt;h3 id=&#34;3nf&#34;&gt;3NF
&lt;/h3&gt;&lt;p&gt;由2NF消除非主属性对键的传递依赖得到
不包含非主属性的对键的部分、传递依赖&lt;/p&gt;
&lt;h3 id=&#34;bcnf&#34;&gt;BCNF
&lt;/h3&gt;&lt;p&gt;由3NF消除主属性对键的&lt;strong&gt;部分和传递依赖&lt;/strong&gt;得到
不包含主属性、非主属性对键的部分和传递依赖&lt;/p&gt;
&lt;h3 id=&#34;4nf&#34;&gt;4NF
&lt;/h3&gt;&lt;p&gt;由BCNF消除&lt;strong&gt;非平凡且非函数依赖&lt;/strong&gt;的多值依赖得到&lt;/p&gt;
&lt;h3 id=&#34;5nf&#34;&gt;5NF
&lt;/h3&gt;&lt;p&gt;由4NF消除非平凡的连接依赖得到&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/nfs.png&#34;
	width=&#34;1383&#34;
	height=&#34;355&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/nfs_hu_c1c0ded694fa508a.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/nfs_hu_5fa213c649ab6922.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;NF&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;389&#34;
		data-flex-basis=&#34;934px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;概念&#34;&gt;概念
&lt;/h1&gt;&lt;h2 id=&#34;函数依赖&#34;&gt;函数依赖
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;可参考 Chapter 7 函数依赖&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;函数依赖保持&#34;&gt;函数依赖保持
&lt;/h3&gt;&lt;h3 id=&#34;区分satisfy与holds-on&#34;&gt;区分satisfy与holds on
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-4.png&#34;
	width=&#34;1857&#34;
	height=&#34;1017&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-4_hu_c3d6c1bffa1ae256.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-4_hu_ae4b454ad7a8d09b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;函数依赖保持与满足的区别&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;438px&#34;
	
&gt;
满足是局部满足，保持是所有合法关系实例都必须满足此FD
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-5.png&#34;
	width=&#34;1535&#34;
	height=&#34;1023&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-5_hu_45240c7a96bfb079.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-5_hu_77986a6470d2c1d1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;360px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;平凡fd&#34;&gt;平凡FD
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-6.png&#34;
	width=&#34;1752&#34;
	height=&#34;525&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-6_hu_5d676a39e93a262d.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-6_hu_e9ab209866b1f62c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Trival FD例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;800px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;主属性与传递依赖&#34;&gt;主属性与传递依赖
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-7.png&#34;
	width=&#34;1839&#34;
	height=&#34;549&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-7_hu_bfd82bf6b8dd22bc.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-7_hu_100f91fd0d2e1716.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Transitive&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;334&#34;
		data-flex-basis=&#34;803px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;部分依赖&#34;&gt;部分依赖
&lt;/h3&gt;&lt;p&gt;左端非最小化&lt;/p&gt;
&lt;h3 id=&#34;函数依赖闭包f&#34;&gt;函数依赖闭包$F^{+}$
&lt;/h3&gt;&lt;p&gt;目的：从已知函数依赖，推导出全部隐含函数依赖&lt;/p&gt;
&lt;h3 id=&#34;函数依赖定义的无损连接分解&#34;&gt;函数依赖定义的无损连接分解
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-8.png&#34;
	width=&#34;1794&#34;
	height=&#34;474&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-8_hu_2f31f466e1d31449.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-8_hu_176bdc86ac5a9e02.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;条件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;378&#34;
		data-flex-basis=&#34;908px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-9.png&#34;
	width=&#34;1785&#34;
	height=&#34;915&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-9_hu_15b47d5e9414eef7.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-9_hu_c2925814dd9913d2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;例子&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;195&#34;
		data-flex-basis=&#34;468px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;范式&#34;&gt;范式
&lt;/h1&gt;&lt;h2 id=&#34;1nf-1&#34;&gt;1NF
&lt;/h2&gt;&lt;p&gt;所有属性都是原子的
A relational schema R is in first normal form if the domains of all attributes of R are atomic.
比如应该把学院放进属性列而非使用学号编码&lt;/p&gt;
&lt;h2 id=&#34;2nf-1&#34;&gt;2NF
&lt;/h2&gt;&lt;p&gt;不存在非主属性对候选键的部分依赖
非主属性要么不依赖，要么完全依赖于候选键&lt;/p&gt;
&lt;h2 id=&#34;bcnf-1&#34;&gt;BCNF
&lt;/h2&gt;&lt;p&gt;不存在非主属性、主属性对候选键的部分、传递依赖
A relation schema R is in BCNF with respect to a set F of functional  dependencies, if for all functional dependencies in $F^{+}$ of the form $\alpha \rightarrow \beta$
where $\alpha \subset \beta $ R and $\beta \subseteq R$, &lt;strong&gt;at least one&lt;/strong&gt; of the following holds:
$\alpha \rightarrow \beta$  is trivial (i.e., $\beta \subseteq \alpha$)
$\alpha$ is a superkey for R
如何分解成BCNF？
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-10.png&#34;
	width=&#34;1773&#34;
	height=&#34;936&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-10_hu_76a914defd60cd33.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-10_hu_725bb9b4a484b43b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;我也不知道为什么在这讲&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;454px&#34;
	
&gt;
说白了就是让不属于原模式超键的属性都变为新模式的主键，并从原模式中去掉依赖式右端的属性&lt;/p&gt;
&lt;h3 id=&#34;分解bcnf也存在函数依赖保持和非保持&#34;&gt;分解BCNF也存在函数依赖保持和非保持
&lt;/h3&gt;&lt;p&gt;总之就一句话：
the functional dependency &lt;br&gt;
s_ID, dept name → i_ID
can &lt;strong&gt;only be checked&lt;/strong&gt; by computing the join of the decomposed relations&lt;/p&gt;
&lt;h2 id=&#34;3nf-1&#34;&gt;3NF
&lt;/h2&gt;&lt;p&gt;Because it is not always possible to achieve both BCNF and dependency preservation, we consider a weaker normal form, known as third normal form (3NF).
A relation schema R is in third normal form with respect to a set F of functional dependencies, if for all functional dependencies in $F^{+}$ of the form $\alpha \rightarrow \beta$
where $\alpha \subset \beta $ R and $\beta \subseteq R$, &lt;strong&gt;at least one&lt;/strong&gt; of the following holds:
$\alpha \rightarrow \beta$  is trivial (i.e., $\beta \subseteq \alpha$)
$\alpha$ is a superkey for R
&lt;em&gt;&lt;strong&gt;Each attribute A in $\beta - \alpha$ is part of some candidate key for R&lt;/strong&gt;&lt;/em&gt;
If a relation is in BCNF, it is also in 3NF (since in BCNF one of the first two conditions above must hold).
Third condition is a minimal &lt;em&gt;relaxation&lt;/em&gt;（放宽） of BCNF to ensure dependency preservation (will see why later)
&lt;img src=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-11.png&#34;
	width=&#34;1143&#34;
	height=&#34;627&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-11_hu_de9a69fa781e77cc.png 480w, https://invalidval.github.io/p/chapter7-%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%967.1-7.3/image-11_hu_ceefd351e9e7deed.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;有点懵逼，自己看吧&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;437px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3nf缺点&#34;&gt;3NF缺点
&lt;/h3&gt;&lt;p&gt;Redundancy in 3NF【缺点:数据冗余】&lt;/p&gt;
&lt;h3 id=&#34;3nf对比bcnf&#34;&gt;3NF对比BCNF
&lt;/h3&gt;&lt;p&gt;Advantages to 3NF over BCNF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is always possible to obtain a 3NF design without sacrificing losslessness or dependency preservation
3NF分解可以保证无损连接、函数依赖保持
BCNF分解保证无损连接，但不保证函数依赖保持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Disadvantages to 3NF&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We may have to use null values to represent some of the possible meaningful relationships among data items.&lt;/li&gt;
&lt;li&gt;There is the problem of repetition of information&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分解目标&#34;&gt;分解目标
&lt;/h2&gt;&lt;p&gt;分解要求：从函数依赖角度
1. 分解为2NF, 3NF, BCNF
2. 必修保证无损连接分解，尽可能保证函数依赖保持&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Chapter 6.8 ISA</title>
        <link>https://invalidval.github.io/p/chapter-6.8-isa/</link>
        <pubDate>Thu, 23 Oct 2025 00:00:00 +0800</pubDate>
        
        <guid>https://invalidval.github.io/p/chapter-6.8-isa/</guid>
        <description>&lt;h1 id=&#34;isa关系68&#34;&gt;ISA关系（6.8）
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ISA Relationship&lt;/strong&gt; 指的是一种特定的&lt;strong&gt;数据建模&lt;/strong&gt;技术，用于在概念模型（如ER图）中表示实体之间的继承关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISA&lt;/strong&gt; 是 &lt;strong&gt;“IS-A”&lt;/strong&gt; 的缩写，例如 “&lt;strong&gt;A Manager IS-AN Employee&lt;/strong&gt;”（一个经理 &lt;strong&gt;是&lt;/strong&gt; 一个员工）。它描述了一种&lt;strong&gt;父类型（超类型）&lt;/strong&gt; 和&lt;strong&gt;子类型&lt;/strong&gt; 之间的层次关系。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;核心概念&#34;&gt;核心概念
&lt;/h3&gt;&lt;p&gt;在数据库设计中，ISA关系用于捕捉现实世界中存在的&lt;strong&gt;分类结构&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;超类型 / 父类：&lt;/strong&gt; 一个更一般化、更抽象的实体。
&lt;ul&gt;
&lt;li&gt;例如：&lt;code&gt;人(Person)&lt;/code&gt;、&lt;code&gt;账户(Account)&lt;/code&gt;、&lt;code&gt;车辆(Vehicle)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子类型 / 子类：&lt;/strong&gt; 一个更具体、更特化的实体，它是超类型的一种。
&lt;ul&gt;
&lt;li&gt;例如：&lt;code&gt;员工(Employee)&lt;/code&gt; 和 &lt;code&gt;学生(Student)&lt;/code&gt; 是 &lt;code&gt;人(Person)&lt;/code&gt; 的子类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;储蓄账户(SavingsAccount)&lt;/code&gt; 和 &lt;code&gt;支票账户(CheckingAccount)&lt;/code&gt; 是 &lt;code&gt;账户(Account)&lt;/code&gt; 的子类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isa关系的两个关键约束&#34;&gt;ISA关系的两个关键约束
&lt;/h3&gt;&lt;p&gt;当你在设计中使用ISA关系时，必须定义两个重要的约束：&lt;/p&gt;
&lt;h4 id=&#34;1-重叠约束disjointoverlapping-constraint&#34;&gt;1. 重叠约束（Disjoint/Overlapping Constraint）
&lt;/h4&gt;&lt;p&gt;规定一个超类型的实例是否可以同时属于多个子类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不允许重叠：&lt;/strong&gt; 一个超类实例只能属于&lt;strong&gt;一个&lt;/strong&gt;子类型。
&lt;ul&gt;
&lt;li&gt;例如：一个 &lt;code&gt;账户(Account)&lt;/code&gt; 要么是 &lt;code&gt;储蓄账户(SavingsAccount)&lt;/code&gt;，要么是 &lt;code&gt;支票账户(CheckingAccount)&lt;/code&gt;，但不能同时是两者。用 &lt;strong&gt;“OR”&lt;/strong&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;允许重叠：&lt;/strong&gt; 一个超类实例可以同时属于&lt;strong&gt;多个&lt;/strong&gt;子类型。
&lt;ul&gt;
&lt;li&gt;例如：一个 &lt;code&gt;人(Person)&lt;/code&gt; 可以同时是 &lt;code&gt;员工(Employee)&lt;/code&gt; 和 &lt;code&gt;学生(Student)&lt;/code&gt;。用 &lt;strong&gt;“AND”&lt;/strong&gt; 表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-完备性约束completeness-constraint&#34;&gt;2. 完备性约束（Completeness constraint）
&lt;/h4&gt;&lt;p&gt;规定超类型中的每一个实例是否都&lt;strong&gt;必须&lt;/strong&gt;至少属于一个子类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全完备性（total）：&lt;/strong&gt; 超类型的&lt;strong&gt;每一个&lt;/strong&gt;实例都&lt;strong&gt;必须&lt;/strong&gt;是某个子类型的实例。
&lt;ul&gt;
&lt;li&gt;例如：公司规定，每一个 &lt;code&gt;员工(Employee)&lt;/code&gt; 都必须是 &lt;code&gt;小时工(HourlyEmployee)&lt;/code&gt; 或 &lt;code&gt;月薪工(SalariedEmployee)&lt;/code&gt; 中的一种。超类型 &lt;code&gt;员工(Employee)&lt;/code&gt; 不会存在不属于任何子类的“孤例”。在ER图中，用&lt;strong&gt;双线&lt;/strong&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分完备性（partial）：&lt;/strong&gt; 超类型的实例&lt;strong&gt;可以&lt;/strong&gt;不属于任何子类型。
&lt;ul&gt;
&lt;li&gt;例如：一个 &lt;code&gt;人(Person)&lt;/code&gt; 可以只是普通人，既不是 &lt;code&gt;员工(Employee)&lt;/code&gt;，也不是 &lt;code&gt;学生(Student)&lt;/code&gt;。在ER图中，用&lt;strong&gt;单线&lt;/strong&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;在数据库中的实现方式&#34;&gt;在数据库中的实现方式
&lt;/h3&gt;&lt;div style=&#34;background-color: #FFFF00&#34;&gt;ISA层次结构在物理数据库中主要有三种实现方式：&lt;/div&gt;
&lt;h4 id=&#34;1-每个具体类一张表&#34;&gt;1. 每个具体类一张表
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法：&lt;/strong&gt; 忽略超类型，只为&lt;strong&gt;每个子类型&lt;/strong&gt;创建一张表。这张表包含该子类型特有的属性，以及从超类型继承来的所有属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例：&lt;/strong&gt; 创建 &lt;code&gt;学生表(Students)&lt;/code&gt; 和 &lt;code&gt;员工表(Employees)&lt;/code&gt;，没有 &lt;code&gt;人表(Persons)&lt;/code&gt;。&lt;code&gt;Students&lt;/code&gt;表中有 &lt;code&gt;student_id, name, age, major&lt;/code&gt; 等字段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 查询特定子类型的数据时速度快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余（如果一个人既是学生又是员工，他的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;信息会在两张表中重复存储）。&lt;/li&gt;
&lt;li&gt;难以对所有人进行统一查询（需要&lt;code&gt;UNION&lt;/code&gt;操作）。&lt;/li&gt;
&lt;li&gt;无法表示不属于任何子类的人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-单张表&#34;&gt;2. 单张表
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法：&lt;/strong&gt; 将整个层次结构“扁平化”为&lt;strong&gt;一张表&lt;/strong&gt;。这张表包含超类型和所有子类型的所有属性。同时，增加一个“类型鉴别”字段来标识每一行属于哪个子类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例：&lt;/strong&gt; 创建一张 &lt;code&gt;人表(Persons)&lt;/code&gt;，包含字段：&lt;code&gt;person_id, name, age, person_type, major, salary, department&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;person_type = ‘Student’&lt;/code&gt;，那么 &lt;code&gt;major&lt;/code&gt; 字段有意义，&lt;code&gt;salary&lt;/code&gt; 字段为NULL。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;person_type = ‘Employee’&lt;/code&gt;，那么 &lt;code&gt;salary&lt;/code&gt; 字段有意义，&lt;code&gt;major&lt;/code&gt; 字段为NULL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 统一查询非常简单，不需要&lt;code&gt;JOIN&lt;/code&gt;操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;表中存在大量&lt;code&gt;NULL&lt;/code&gt;值，浪费存储空间。&lt;/li&gt;
&lt;li&gt;表结构会随着子类型的增加而变得非常庞大和复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-超类型和子类型分别建表&#34;&gt;3. 超类型和子类型分别建表
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法：&lt;/strong&gt; 为&lt;strong&gt;超类型&lt;/strong&gt;和&lt;strong&gt;每一个子类型&lt;/strong&gt;都创建一张表。
&lt;ul&gt;
&lt;li&gt;超类型表包含所有实例共享的公共属性（和一个主键）。&lt;/li&gt;
&lt;li&gt;子类型表只包含其特有的属性，并&lt;strong&gt;共享超类型表的主键&lt;/strong&gt;（即子类型表的主键同时也是引用超类型表的外键）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;人表(Persons)&lt;/code&gt;：&lt;code&gt;person_id (PK), name, age&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;学生表(Students)&lt;/code&gt;：&lt;code&gt;person_id (PK, FK references Persons), major&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;员工表(Employees)&lt;/code&gt;：&lt;code&gt;person_id (PK, FK references Persons), salary, department&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;设计规范，消除了数据冗余。&lt;/li&gt;
&lt;li&gt;易于添加新的子类型。&lt;/li&gt;
&lt;li&gt;能很好地支持重叠约束（一个人可以同时在&lt;code&gt;Students&lt;/code&gt;和&lt;code&gt;Employees&lt;/code&gt;表中有记录）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 查询数据时需要频繁使用&lt;code&gt;JOIN&lt;/code&gt;操作，性能可能成为瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;在数据库领域中，&lt;strong&gt;ISA Relationship&lt;/strong&gt; 是一个强大的概念建模工具，它清晰地表达了 &lt;strong&gt;“是一个”&lt;/strong&gt; 的继承关系。理解并正确定义其&lt;strong&gt;重叠约束&lt;/strong&gt;和&lt;strong&gt;完备性约束&lt;/strong&gt;至关重要，因为它直接影响到最终数据库表结构的设计选择（每种实现方式都有其优缺点，需要根据具体应用场景进行权衡）。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Chapter6 ER模型</title>
        <link>https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Thu, 23 Oct 2025 00:00:00 +0800</pubDate>
        
        <guid>https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;h1 id=&#34;chapter-6-the-entity-relationship-model&#34;&gt;Chapter 6 The Entity-Relationship Model
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/erd.png&#34;
	width=&#34;1171&#34;
	height=&#34;1073&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/erd_hu_7397ce272e3e7e02.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/erd_hu_f0fd75825304ea4b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;ER diagram&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;109&#34;
		data-flex-basis=&#34;261px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;entity-sets实体集实体型&#34;&gt;Entity Sets（实体集，实体型）
&lt;/h2&gt;&lt;p&gt;一张学生表是一个实体集，一个学生是一个实体（一行记录）&lt;/p&gt;
&lt;h2 id=&#34;relationship-sets关系集&#34;&gt;Relationship Sets(关系集)
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;选课表&lt;/code&gt;就是一个&lt;code&gt;关系集&lt;/code&gt;。它定义了“学生”和“课程”之间的“选修”这种关系。&lt;code&gt;关系&lt;/code&gt;表示特定实体之间的一次具体关联。它对应的是联系表中的一行&lt;code&gt;记录&lt;/code&gt;。
关系集也可以拥有自己的&lt;code&gt;属性&lt;/code&gt;（&lt;strong&gt;关系集属性&lt;/strong&gt;），用于描述关系的特征。它同样对应联系表中的列。选课表这个关系集可以有&lt;code&gt;成绩、选修日期&lt;/code&gt;等属性，这些属性不属于学生，也不属于课程，而是属于“选修”这个行为本身。&lt;/p&gt;
&lt;h2 id=&#34;choice-of-primary-key-for-binary-relationship&#34;&gt;Choice of Primary key for Binary Relationship
&lt;/h2&gt;&lt;p&gt;在多的那一端把一的主键拿过来当外键&lt;/p&gt;
&lt;h2 id=&#34;多元联系non-binary&#34;&gt;多元联系(non-binary)
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/nonebinary.png&#34;
	width=&#34;933&#34;
	height=&#34;359&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/nonebinary_hu_90ed7bc08ea5076e.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/nonebinary_hu_8a18ac6277bc90b4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;三元Ternary Relationship&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;623px&#34;
	
&gt;
先转成多个二元联系再转表：将其他实体集的主键和关系自身属性建成表，各实体集不存放多余属性。&lt;/p&gt;
&lt;h2 id=&#34;e-r图概念设计结果&#34;&gt;E-R图（概念设计结果）
&lt;/h2&gt;&lt;h3 id=&#34;representing-cardinality-constraints-in-er-diagram&#34;&gt;Representing Cardinality Constraints in ER Diagram
&lt;/h3&gt;&lt;p&gt;→：一
—：多
(one,many) x (one,many) = 4 种&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/onetoone.png&#34;
	width=&#34;1077&#34;
	height=&#34;283&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/onetoone_hu_4b3b28947f5fe4df.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/onetoone_hu_b4e9fa82a8ffafb9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;一对一&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;380&#34;
		data-flex-basis=&#34;913px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;参与约束participant-constraints&#34;&gt;参与约束(Participant Constraints)
&lt;/h3&gt;&lt;p&gt;完全参与、部分参与&lt;/p&gt;
&lt;h2 id=&#34;逻辑设计阶段&#34;&gt;逻辑设计阶段
&lt;/h2&gt;&lt;p&gt;E-R图转关系模式
实体、联系、属性（单值属性、多值属性、复合属性）如何转表？
多值属性单独转表
复合属性拆开（如时间、地址）&lt;/p&gt;
&lt;p&gt;弱实体集、强实体集；
用实体还是属性？
Not to use the &lt;code&gt;primary-key&lt;/code&gt; of an entity set as an attributes of another entity set (to represent implicitly association between these two entity sets), it is better to use an relationship set  to explicitly show this association
e.g.  for the entity student, do not use instructor.id as its attribute, in stead of,  representing association among student and instructor using &lt;code&gt;relationship&lt;/code&gt; advisor.&lt;/p&gt;
&lt;p&gt;用实体还是关系？“动作”对应“联系”&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/weake.png&#34;
	width=&#34;1811&#34;
	height=&#34;1026&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/weake_hu_75aeef19b0c5a435.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/weake_hu_8882bfca8686d0a2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;弱实体集&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;176&#34;
		data-flex-basis=&#34;423px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;扩展er-详情看isa那篇&#34;&gt;扩展ER （详情看ISA那篇）
&lt;/h2&gt;&lt;h3 id=&#34;面向对象erobject-oriented-oo-e-r&#34;&gt;面向对象ER：Object-oriented (OO) E-R
&lt;/h3&gt;&lt;p&gt;specialization （特化，特殊化，例化）
自上而下，底层实体集是高层实体集的真子集
高层：超类；底层：子类&lt;/p&gt;
&lt;p&gt;generalization (概括化，泛化，普遍化)
自底向上&lt;/p&gt;
&lt;p&gt;attributes inheritance （属性继承）
联系也可以继承&lt;/p&gt;
&lt;h3 id=&#34;aggregation&#34;&gt;Aggregation
&lt;/h3&gt;&lt;p&gt;relationship on relationship（联系的联系）&lt;/p&gt;
&lt;h2 id=&#34;er图记号总结&#34;&gt;ER图记号总结
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/notation.png&#34;
	width=&#34;1448&#34;
	height=&#34;830&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/notation_hu_2e71417dac28c066.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/notation_hu_eae70deb99dd7e5b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;记号&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-1.png&#34;
	width=&#34;1340&#34;
	height=&#34;910&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-1_hu_2eca5d22e9091c97.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-1_hu_148bcaec67969326.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;记号（续）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;353px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-2.png&#34;
	width=&#34;1765&#34;
	height=&#34;988&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-2_hu_d48f4362889822da.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-2_hu_75aeac4bc8f0ad8c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;替代记号&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;
&lt;img src=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-3.png&#34;
	width=&#34;1839&#34;
	height=&#34;1011&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-3_hu_f9791aa57282eeee.png 480w, https://invalidval.github.io/p/chapter6-er%E6%A8%A1%E5%9E%8B/image-3_hu_b8fd75e1fb94a904.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;替代记号（续）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;436px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Chapter2 关系数据库基础</title>
        <link>https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Sun, 01 Jan 2023 00:00:00 +0800</pubDate>
        
        <guid>https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h1 id=&#34;关系数据库结构&#34;&gt;关系数据库结构
&lt;/h1&gt;&lt;p&gt;table、relation、attributes&lt;/p&gt;
&lt;h1 id=&#34;key&#34;&gt;key
&lt;/h1&gt;&lt;p&gt;A &lt;code&gt;superkey&lt;/code&gt; (超键) is a set of one or more attributes that, taken collectively, can be used to identify uniquely a tuple in the relation.&lt;/p&gt;
&lt;p&gt;K is a &lt;code&gt;candidate key&lt;/code&gt; (候选键) if K is minimal super key. e.g.{ID} is a candidate key for instructor, assuming no two instructors can possibly have the same identifiers.
A &lt;code&gt;relation&lt;/code&gt; may have several &lt;code&gt;candidate keys&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Primary key&lt;/code&gt; (主键) is a candidate key chosen by the database designer as principal means to identify tuples within a relation&lt;/p&gt;
&lt;p&gt;Def. &lt;code&gt;Primary attributes&lt;/code&gt; (主属性!)
taking the key as a attribute set,  the attributes in the candidate keys, i.e. the element of the primary key is called the primary attributes
&lt;code&gt;non-primary attributes&lt;/code&gt; (非主属性)&lt;/p&gt;
&lt;p&gt;Super key &amp;gt;= candidate key &amp;gt;= primary key&lt;/p&gt;
&lt;h1 id=&#34;relational-algebra-关系代数&#34;&gt;relational algebra (关系代数)
&lt;/h1&gt;&lt;h2 id=&#34;six-basic-operators&#34;&gt;Six basic operators
&lt;/h2&gt;&lt;p&gt;(选择) select: $\sigma$
(投影) project:
(笛卡尔积) Cartesian product: x
(集合并) union:
(集合差) set difference: –
(重命名) rename:
&lt;img src=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/alg.png&#34;
	width=&#34;1155&#34;
	height=&#34;858&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/alg_hu_437309c250861868.png 480w, https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/alg_hu_de816a7d8886c9b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;323px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;复合关系运算&#34;&gt;复合关系运算
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/join.png&#34;
	width=&#34;1761&#34;
	height=&#34;657&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/join_hu_81b7bbe814a81538.png 480w, https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/join_hu_9972cf8518627a6a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;268&#34;
		data-flex-basis=&#34;643px&#34;
	
&gt;
暂时值（Assignment）
&lt;img src=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/as.png&#34;
	width=&#34;1800&#34;
	height=&#34;549&#34;
	srcset=&#34;https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/as_hu_cff2afed3258b1f9.png 480w, https://invalidval.github.io/p/chapter2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/as_hu_7b878884a20c71ee.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;327&#34;
		data-flex-basis=&#34;786px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
